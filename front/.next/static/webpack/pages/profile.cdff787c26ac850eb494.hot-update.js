/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/profile",{

/***/ "./components/ProfileEditForm.js":
/*!***************************************!*\
  !*** ./components/ProfileEditForm.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-hook-form */ \"./node_modules/react-hook-form/dist/index.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\nvar _jsxFileName = \"/Users/seanstainability/Projects/twitter/front/components/ProfileEditForm.js\",\n    _this = undefined;\n\n\n\n\nvar ProfileEditForm = function ProfileEditForm() {\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 5,\n    columnNumber: 10\n  }, _this);\n};\n\n_c = ProfileEditForm;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ProfileEditForm);\n\nvar _c;\n\n$RefreshReg$(_c, \"ProfileEditForm\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Qcm9maWxlRWRpdEZvcm0uanM/MWYyZCJdLCJuYW1lcyI6WyJQcm9maWxlRWRpdEZvcm0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUEsSUFBTUEsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixHQUFNO0FBQzVCLHNCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBUDtBQUNELENBRkQ7O0tBQU1BLGU7QUFJTiwrREFBZUEsZUFBZiIsImZpbGUiOiIuL2NvbXBvbmVudHMvUHJvZmlsZUVkaXRGb3JtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRm9ybSB9IGZyb20gXCJyZWFjdC1ob29rLWZvcm1cIjtcblxuY29uc3QgUHJvZmlsZUVkaXRGb3JtID0gKCkgPT4ge1xuICByZXR1cm4gPGRpdj48L2Rpdj47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9maWxlRWRpdEZvcm07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/ProfileEditForm.js\n");

/***/ }),

/***/ "./node_modules/react-hook-form/dist/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Controller\": function() { return /* binding */ Controller; },\n/* harmony export */   \"FormProvider\": function() { return /* binding */ FormProvider; },\n/* harmony export */   \"appendErrors\": function() { return /* binding */ appendErrors; },\n/* harmony export */   \"get\": function() { return /* binding */ get; },\n/* harmony export */   \"set\": function() { return /* binding */ set; },\n/* harmony export */   \"useController\": function() { return /* binding */ useController; },\n/* harmony export */   \"useFieldArray\": function() { return /* binding */ useFieldArray; },\n/* harmony export */   \"useForm\": function() { return /* binding */ useForm; },\n/* harmony export */   \"useFormContext\": function() { return /* binding */ useFormContext; },\n/* harmony export */   \"useFormState\": function() { return /* binding */ useFormState; },\n/* harmony export */   \"useWatch\": function() { return /* binding */ useWatch; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (data) => data instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FormContext);\r\nconst FormProvider = (props) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n        Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n            (isRoot ? VALIDATION_MODE.all : true)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nfunction useFormState(props) {\r\n    const { control, name } = props || {};\r\n    const methods = useFormContext();\r\n    const { formStateRef, subjectsRef, readFormStateRef } = control || methods.control;\r\n    const nameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\r\n    nameRef.current = name;\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(formStateRef.current);\r\n    const readFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const formStateSubscription = subjectsRef.current.state.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState)),\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, namesRef, subjectsRef, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const field = get(fieldsRef.current, name);\r\n    const [value, setInputStateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(field && field._f && !isUndefined(field._f.value)\r\n        ? field._f.value\r\n        : isUndefined(get(defaultValuesRef.current, name))\r\n            ? defaultValue\r\n            : get(defaultValuesRef.current, name));\r\n    const { onChange, onBlur, ref } = register(name, Object.assign(Object.assign({}, rules), { value }));\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    function updateIsMounted(name, value) {\r\n        const field = get(fieldsRef.current, name);\r\n        if (field && field._f) {\r\n            field._f.mount = value;\r\n        }\r\n    }\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const controllerSubscription = subjectsRef.current.control.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        updateIsMounted(name, true);\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const shouldUnmountField = shouldUnmount || shouldUnregister;\r\n            if (isNameInFieldArray(namesRef.current.array, name)\r\n                ? shouldUnmountField && !inFieldArrayActionRef.current\r\n                : shouldUnmountField) {\r\n                unregister(name);\r\n            }\r\n            else {\r\n                updateIsMounted(name, false);\r\n            }\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm &&\r\n                ref({\r\n                    focus: () => elm.focus && elm.focus(),\r\n                    setCustomValidity: (message) => elm.setCustomValidity(message),\r\n                    reportValidity: () => elm.reportValidity(),\r\n                }),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field && !isNullOrUndefined(output)) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f && _f.ref\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            current &&\r\n                getFieldsValues({\r\n                    current,\r\n                }, output[name]);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        isDateObject(object1) ||\r\n        isDateObject(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                !isNullOrUndefined(defaultValues) &&\r\n                    deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...convertToArrayPayload(data), ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...convertToArrayPayload(data)];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\r\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n    const { getIsDirty, namesRef, fieldsRef, defaultValuesRef, formStateRef, subjectsRef, readFormStateRef, updateIsValid, fieldArrayDefaultValuesRef, unregister, shouldUnmount, inFieldArrayActionRef, setValues, register, } = control || methods.control;\r\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(mapIds((get(fieldsRef.current, name) && isMountedRef.current\r\n        ? get(getFieldsValues(fieldsRef), name)\r\n        : get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n            ? get(fieldArrayDefaultValuesRef.current, name)\r\n            : get(defaultValuesRef.current, name)) || [], keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    namesRef.current.array.add(name);\r\n    const omitKey = (fields) => fields.map((field = {}) => omit(field, keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusFieldName = (index, options) => options && !options.shouldFocus\r\n        ? options.focusName || `${name}.${options.focusIndex}.`\r\n        : `${name}.${index}.`;\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        inFieldArrayActionRef.current = true;\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updatedFieldArrayValues &&\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        subjectsRef.current.state.next({\r\n            dirtyFields: formStateRef.current\r\n                .dirtyFields,\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => {\r\n        const rootName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}`;\r\n        isPrimitive(appendValueItem)\r\n            ? register(rootName, {\r\n                value: appendValueItem,\r\n            })\r\n            : Object.entries(appendValueItem).forEach(([key, value]) => {\r\n                const inputName = rootName + '.' + key;\r\n                Array.isArray(value)\r\n                    ? registerFieldArray(value, valueIndex, inputName)\r\n                    : register(inputName, { value });\r\n            });\r\n    });\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusFieldName(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusFieldName(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusFieldName(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    const update = (index, value) => {\r\n        setValues((name + '.' + index), value, {\r\n            shouldValidate: !!readFormStateRef.current.isValid,\r\n            shouldDirty: !!(readFormStateRef.current.dirtyFields ||\r\n                readFormStateRef.current.isDirty),\r\n        });\r\n        const fieldValues = getCurrentFieldsValues();\r\n        fieldValues[index] = value;\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        inFieldArrayActionRef.current = false;\r\n        if (namesRef.current.watchAll) {\r\n            subjectsRef.current.state.next({});\r\n        }\r\n        else {\r\n            for (const watchField of namesRef.current.watch) {\r\n                if (name.startsWith(watchField)) {\r\n                    subjectsRef.current.state.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        subjectsRef.current.watch.next({\r\n            name,\r\n            values: getFieldsValues(fieldsRef),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        subjectsRef.current.array.next({\r\n            name,\r\n            values: omitKey([...fields]),\r\n        });\r\n        readFormStateRef.current.isValid && updateIsValid();\r\n    }, [fields, name]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const fieldArraySubscription = subjectsRef.current.array.subscribe({\r\n            next({ name: inputFieldArrayName, values, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, values)\r\n                        : (fieldArrayDefaultValuesRef.current = values);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        isMountedRef.current = true;\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            if (shouldUnmount || shouldUnregister) {\r\n                unregister(name);\r\n                unset(fieldArrayDefaultValuesRef.current, name);\r\n            }\r\n            else {\r\n                const fieldArrayValues = get(getFieldsValues(fieldsRef), name);\r\n                fieldArrayValues &&\r\n                    set(fieldArrayDefaultValuesRef.current, name, fieldArrayValues);\r\n            }\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [name]),\r\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [name]),\r\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend$1, [name]),\r\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append$1, [name]),\r\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [name]),\r\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [name]),\r\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar getResolverOptions = (fieldsNames, fieldsRefs, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isString = (value) => typeof value === 'string';\n\nvar isMessage = (value) => isString(value) || react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, mount, }, }, validateAllFieldCriteria, shouldUseNativeValidation) => {\r\n    if (!mount) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidty = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: inputRef }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidty(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    setCustomValidty(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: inputRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidty(true);\r\n    return error;\r\n};\n\nvar debounce = (callback, wait) => {\r\n    let timer = 0;\r\n    return (...args) => {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(() => callback(...args), wait);\r\n    };\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, delayError, shouldUseNativeValidation, shouldUnregister, criteriaMode, } = {}) {\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const resolverRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(resolver);\r\n    const formStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(formState);\r\n    const fieldsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\r\n    const defaultValuesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValues);\r\n    const fieldArrayDefaultValuesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\r\n    const contextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(context);\r\n    const inFieldArrayActionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n    const _delayCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\r\n    const subjectsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\r\n        watch: new Subject(),\r\n        control: new Subject(),\r\n        array: new Subject(),\r\n        state: new Subject(),\r\n    });\r\n    const namesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n        watchAll: false,\r\n    });\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    resolverRef.current = resolver;\r\n    contextRef.current = context;\r\n    const isFieldWatched = (name) => namesRef.current.watchAll ||\r\n        namesRef.current.watch.has(name) ||\r\n        namesRef.current.watch.has((name.match(/\\w+/) || [])[0]);\r\n    const updateErrorState = (name, error) => {\r\n        set(formStateRef.current.errors, name, error);\r\n        subjectsRef.current.state.next({\r\n            errors: formStateRef.current.errors,\r\n        });\r\n    };\r\n    const shouldRenderBaseOnValid = async () => {\r\n        const isValid = await validateForm(fieldsRef.current, true);\r\n        if (isValid !== formStateRef.current.isValid) {\r\n            formStateRef.current.isValid = isValid;\r\n            subjectsRef.current.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderBaseOnError = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (shouldSkipRender, name, error, fieldState, isValidFromResolver, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        const isValid = readFormStateRef.current.isValid\r\n            ? resolver\r\n                ? isValidFromResolver\r\n                : shouldRenderBaseOnValid()\r\n            : false;\r\n        if (delayError && error) {\r\n            _delayCallback.current =\r\n                _delayCallback.current || debounce(updateErrorState, delayError);\r\n            _delayCallback.current(name, error);\r\n        }\r\n        else {\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((isWatched ||\r\n            (error ? !deepEqual(previousError, error) : previousError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            formStateRef.current.isValid !== isValid) &&\r\n            !shouldSkipRender) {\r\n            const updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), (resolver ? { isValid: !!isValid } : {})), { errors: formStateRef.current.errors, name });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            subjectsRef.current.state.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        subjectsRef.current.state.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                    ? ''\r\n                    : rawValue;\r\n                _f.value = getFieldValueAs(rawValue, _f);\r\n                if (isRadioInput(_f.ref)) {\r\n                    (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n                }\r\n                else if (isFileInput(_f.ref) && !isString(value)) {\r\n                    _f.ref.files = value;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n                }\r\n                else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                    _f.refs.length > 1\r\n                        ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                            ? !!value.find((data) => data === checkboxRef.value)\r\n                            : value === checkboxRef.value))\r\n                        : (_f.refs[0].checked = !!value);\r\n                }\r\n                else {\r\n                    _f.ref.value = value;\r\n                }\r\n                if (shouldRender) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, name, rawValue);\r\n                    subjectsRef.current.control.next({\r\n                        values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                        name,\r\n                    });\r\n                }\r\n                (options.shouldDirty || options.shouldTouch) &&\r\n                    updateTouchAndDirtyState(name, value, options.shouldTouch);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n            else {\r\n                field._f = {\r\n                    ref: {\r\n                        name,\r\n                        value: rawValue,\r\n                    },\r\n                    value: rawValue,\r\n                };\r\n            }\r\n        }\r\n    }, []);\r\n    const getIsDirty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateTouchAndDirtyState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((name, inputValue, isCurrentTouched, shouldRender = true) => {\r\n        const state = {\r\n            name,\r\n        };\r\n        let isChanged = false;\r\n        if (readFormStateRef.current.isDirty) {\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            state.isDirty = formStateRef.current.isDirty;\r\n            isChanged = previousIsDirty !== state.isDirty;\r\n        }\r\n        if (readFormStateRef.current.dirtyFields && !isCurrentTouched) {\r\n            const isPreviousFieldDirty = get(formStateRef.current.dirtyFields, name);\r\n            const isCurrentFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            isCurrentFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            state.dirtyFields = formStateRef.current.dirtyFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    isPreviousFieldDirty !== get(formStateRef.current.dirtyFields, name);\r\n        }\r\n        const isPreviousFieldTouched = get(formStateRef.current.touchedFields, name);\r\n        if (isCurrentTouched && !isPreviousFieldTouched) {\r\n            set(formStateRef.current.touchedFields, name, isCurrentTouched);\r\n            state.touchedFields = formStateRef.current.touchedFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    (readFormStateRef.current.touchedFields &&\r\n                        isPreviousFieldTouched !== isCurrentTouched);\r\n        }\r\n        isChanged && shouldRender && subjectsRef.current.state.next(state);\r\n        return isChanged ? state : {};\r\n    }, []);\r\n    const executeInlineValidation = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria, shouldUseNativeValidation))[name];\r\n        await shouldRenderBaseOnError(skipReRender, name, error);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeResolverValidation = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation));\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            formStateRef.current.errors = errors;\r\n        }\r\n        return errors;\r\n    }, [criteriaMode, shouldUseNativeValidation]);\r\n    const validateForm = async (fieldsRef, shouldCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria, shouldUseNativeValidation);\r\n                    if (shouldCheckValid) {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        fieldError[_f.name]\r\n                            ? set(formStateRef.current.errors, _f.name, fieldError[_f.name])\r\n                            : unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current, shouldCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const trigger = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (name, options = {}) => {\r\n        const fieldNames = convertToArrayPayload(name);\r\n        let isValid;\r\n        subjectsRef.current.state.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolver) {\r\n            const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\r\n            isValid = name\r\n                ? fieldNames.every((name) => !get(schemaResult, name))\r\n                : isEmptyObject(schemaResult);\r\n        }\r\n        else {\r\n            if (name) {\r\n                isValid = (await Promise.all(fieldNames\r\n                    .filter((fieldName) => get(fieldsRef.current, fieldName, {})._f)\r\n                    .map(async (fieldName) => await executeInlineValidation(fieldName, true)))).every(Boolean);\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n                isValid = isEmptyObject(formStateRef.current.errors);\r\n            }\r\n        }\r\n        subjectsRef.current.state.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: formStateRef.current.errors, isValidating: false }));\r\n        if (options.shouldFocus && !isValid) {\r\n            focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), name ? fieldNames : namesRef.current.mount);\r\n        }\r\n        readFormStateRef.current.isValid && updateIsValid();\r\n        return isValid;\r\n    }, [executeResolverValidation, executeInlineValidation]);\r\n    const updateIsValidAndInputValue = (name, ref, shouldSkipValueAs) => {\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const isValueUndefined = isUndefined(field._f.value);\r\n            const defaultValue = isValueUndefined\r\n                ? isUndefined(get(fieldArrayDefaultValuesRef.current, name))\r\n                    ? get(defaultValuesRef.current, name)\r\n                    : get(fieldArrayDefaultValuesRef.current, name)\r\n                : field._f.value;\r\n            if (!isUndefined(defaultValue)) {\r\n                if (ref && ref.defaultChecked) {\r\n                    field._f.value = getFieldValue(field);\r\n                }\r\n                else if (shouldSkipValueAs) {\r\n                    field._f.value = defaultValue;\r\n                }\r\n                else {\r\n                    setFieldValue(name, defaultValue);\r\n                }\r\n            }\r\n            else if (isValueUndefined) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n        }\r\n        isMountedRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n    };\r\n    const updateIsValid = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (values = {}) => {\r\n        const isValid = resolver\r\n            ? isEmptyObject((await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation))).errors)\r\n            : await validateForm(fieldsRef.current, true);\r\n        if (isValid !== formStateRef.current.isValid) {\r\n            formStateRef.current.isValid = isValid;\r\n            subjectsRef.current.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    }, [criteriaMode, shouldUseNativeValidation]);\r\n    const setValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\r\n        const fieldName = `${name}.${fieldKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        const isFieldArray = namesRef.current.array.has(name);\r\n        (isFieldArray || !isPrimitive(fieldValue) || (field && !field._f)) &&\r\n            !isDateObject(fieldValue)\r\n            ? setValues(fieldName, fieldValue, options)\r\n            : setFieldValue(fieldName, fieldValue, options, true, !field);\r\n    }), [trigger]);\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = namesRef.current.array.has(name);\r\n        if (isFieldArray) {\r\n            subjectsRef.current.array.next({\r\n                values: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                subjectsRef.current.state.next({\r\n                    name,\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        ((field && !field._f) || isFieldArray) && !isNullOrUndefined(value)\r\n            ? setValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && subjectsRef.current.state.next({});\r\n        subjectsRef.current.watch.next({ name, values: getValues() });\r\n    };\r\n    const handleValidate = async (target, fieldState, isWatched, isBlurEvent) => {\r\n        let error;\r\n        let isValid;\r\n        let name = target.name;\r\n        const field = get(fieldsRef.current, name);\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, getResolverOptions([name], fieldsRef.current, criteriaMode, shouldUseNativeValidation));\r\n            error = get(errors, name);\r\n            if (isCheckBoxInput(target) && !error) {\r\n                const parentNodeName = getNodeParentName(name);\r\n                const currentError = get(errors, parentNodeName, {});\r\n                currentError.type && currentError.message && (error = currentError);\r\n                if (currentError || get(formStateRef.current.errors, parentNodeName)) {\r\n                    name = parentNodeName;\r\n                }\r\n            }\r\n            isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            error = (await validateField(field, isValidateAllFieldCriteria, shouldUseNativeValidation))[name];\r\n        }\r\n        !isBlurEvent &&\r\n            subjectsRef.current.watch.next({\r\n                name,\r\n                type: target.type,\r\n                values: getValues(),\r\n            });\r\n        shouldRenderBaseOnError(false, name, error, fieldState, isValid, isWatched);\r\n    };\r\n    const handleChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async ({ type, target, target: { value, name, type: inputType } }) => {\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !resolver &&\r\n                !get(formStateRef.current.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const fieldState = updateTouchAndDirtyState(name, field._f.value, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    subjectsRef.current.watch.next({\r\n                        name,\r\n                        type,\r\n                        values: getValues(),\r\n                    });\r\n                return (shouldRender &&\r\n                    subjectsRef.current.state.next(isWatched ? { name } : Object.assign(Object.assign({}, fieldState), { name })));\r\n            }\r\n            subjectsRef.current.state.next({\r\n                isValidating: true,\r\n            });\r\n            handleValidate(target, fieldState, isWatched, isBlurEvent);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(formStateRef.current.errors, inputName))\r\n            : (formStateRef.current.errors = {});\r\n        subjectsRef.current.state.next({\r\n            errors: formStateRef.current.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        subjectsRef.current.state.next({\r\n            name,\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = formValues || isMountedRef.current\r\n            ? Object.assign(Object.assign({}, defaultValuesRef.current), (formValues || getFieldsValues(fieldsRef))) : isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : isArrayNames\r\n                ? defaultValue\r\n                : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (namesRef.current.watchAll = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && namesRef.current.watch.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? subjectsRef.current.watch.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? convertToArrayPayload(name)\r\n            : namesRef.current.mount) {\r\n            namesRef.current.mount.delete(inputName);\r\n            namesRef.current.array.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(defaultValuesRef.current, inputName);\r\n            }\r\n        }\r\n        subjectsRef.current.watch.next({\r\n            values: getValues(),\r\n        });\r\n        subjectsRef.current.state.next(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })));\r\n        !options.keepIsValid && updateIsValid();\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        register(name, options);\r\n        let field = get(fieldsRef.current, name);\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isRadioOrCheckbox &&\r\n                compact(field._f.refs || []).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(fieldsRef.current, name, field);\r\n        updateIsValidAndInputValue(name, ref);\r\n    };\r\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((name, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        namesRef.current.mount.add(name);\r\n        !field && updateIsValidAndInputValue(name, undefined, true);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(fieldsRef.current, name, {});\r\n                        const shouldUnmount = shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                            // If initial state of field element is disabled,\r\n                            // value is not set on first \"register\"\r\n                            // re-sync the value in when it switched to enabled\r\n                            if (isUndefined(field._f.value)) {\r\n                                field._f.value = field._f.ref.value;\r\n                            }\r\n                        }\r\n                        shouldUnmount &&\r\n                            !(isNameInFieldArray(namesRef.current.array, name) &&\r\n                                inFieldArrayActionRef.current) &&\r\n                            namesRef.current.unMount.add(name);\r\n                    }\r\n                },\r\n            };\r\n    }, []);\r\n    const handleSubmit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = getFieldsValues(fieldsRef);\r\n        subjectsRef.current.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolver) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, getResolverOptions(namesRef.current.mount, fieldsRef.current, criteriaMode, shouldUseNativeValidation));\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                subjectsRef.current.state.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), namesRef.current.mount);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            subjectsRef.current.state.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [\r\n        shouldFocusError,\r\n        isValidateAllFieldCriteria,\r\n        criteriaMode,\r\n        shouldUseNativeValidation,\r\n    ]);\r\n    const registerAbsentFields = (defaultValues, name = '') => {\r\n        for (const key in defaultValues) {\r\n            const value = defaultValues[key];\r\n            const fieldName = name + (name ? '.' : '') + key;\r\n            const field = get(fieldsRef.current, fieldName);\r\n            if (!field || !field._f) {\r\n                if (isObject(value) || Array.isArray(value)) {\r\n                    registerAbsentFields(value, fieldName);\r\n                }\r\n                else if (!field) {\r\n                    register(fieldName, { value });\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of namesRef.current.mount) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            defaultValuesRef.current = Object.assign({}, updatedValues);\r\n            fieldArrayDefaultValuesRef.current = Object.assign({}, updatedValues);\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            subjectsRef.current.control.next({\r\n                values: keepStateOptions.keepDefaultValues\r\n                    ? defaultValuesRef.current\r\n                    : Object.assign({}, updatedValues),\r\n            });\r\n            subjectsRef.current.watch.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            subjectsRef.current.array.next({\r\n                values: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        namesRef.current = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n        };\r\n        subjectsRef.current.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? formStateRef.current.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : keepStateOptions.keepDefaultValues\r\n                    ? deepEqual(values, defaultValuesRef.current)\r\n                    : false,\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? formStateRef.current.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirty\r\n                ? formStateRef.current.dirtyFields\r\n                : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? formStateRef.current.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n        isMountedRef.current = !!keepStateOptions.keepIsValid;\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const formStateSubscription = subjectsRef.current.state.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    updateFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = subjectsRef.current.array.subscribe({\r\n            next(state) {\r\n                if (state.values && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.values);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        return () => {\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        const unregisterFieldNames = [];\r\n        const isLiveInDom = (ref) => !isHTMLElement(ref) || !document.contains(ref);\r\n        if (!isMountedRef.current) {\r\n            isMountedRef.current = true;\r\n            readFormStateRef.current.isValid && updateIsValid();\r\n            !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\r\n        }\r\n        for (const name of namesRef.current.unMount) {\r\n            const field = get(fieldsRef.current, name);\r\n            field &&\r\n                (field._f.refs\r\n                    ? field._f.refs.every(isLiveInDom)\r\n                    : isLiveInDom(field._f.ref)) &&\r\n                unregisterFieldNames.push(name);\r\n        }\r\n        unregisterFieldNames.length &&\r\n            unregister(unregisterFieldNames);\r\n        namesRef.current.unMount = new Set();\r\n    });\r\n    return {\r\n        control: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n            register,\r\n            inFieldArrayActionRef,\r\n            getIsDirty,\r\n            subjectsRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            updateIsValid,\r\n            namesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            setValues,\r\n            unregister,\r\n            shouldUnmount: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(watch, []),\r\n        setValue: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(setValue, [setValues]),\r\n        getValues: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(getValues, []),\r\n        reset: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(reset, []),\r\n        clearErrors: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(clearErrors, []),\r\n        unregister: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(unregister, []),\r\n        setError: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(setError, []),\r\n        setFocus: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, subjectsRef } = control || methods.control;\r\n    const [value, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = subjectsRef.current.watch.subscribe({\r\n            next: ({ name: inputName, values }) => (!nameRef.current ||\r\n                !inputName ||\r\n                convertToArrayPayload(nameRef.current).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(watchInternal(nameRef.current, defaultValue, false, values)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5qcz8zNGEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnREFBbUI7QUFDdkM7QUFDQSw2QkFBNkIsNkNBQWdCO0FBQzdDLGlDQUFpQyxnREFBbUIsd0JBQXdCLGlDQUFpQzs7QUFFN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCxvQkFBb0IseUNBQVk7QUFDaEM7QUFDQSx5Q0FBeUMsMkNBQWM7QUFDdkQsMEJBQTBCLHlDQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsU0FBUztBQUNUO0FBQ0EsS0FB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QTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLDBDQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQWlCO0FBQ2hDLGtCQUFrQiw4Q0FBaUI7QUFDbkMsbUJBQW1CLDhDQUFpQjtBQUNwQyxlQUFlLDhDQUFpQjtBQUNoQyxxQkFBcUIsOENBQWlCO0FBQ3RDLG9CQUFvQiw4Q0FBaUI7QUFDckMsa0JBQWtCLDhDQUFpQjtBQUNuQyxrQkFBa0IsOENBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNBLG9CQUFvQix5Q0FBWTtBQUNoQztBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLGlDQUFpQywyQ0FBYztBQUMvQztBQUNBO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFMkk7QUFDM0kiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNDaGVja0JveElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxudmFyIGlzRGF0ZU9iamVjdCA9IChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgRGF0ZTtcblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuXG5jb25zdCBpc09iamVjdFR5cGUgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XHJcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxyXG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXHJcbiAgICBpc09iamVjdFR5cGUodmFsdWUpICYmXHJcbiAgICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcblxudmFyIGdldENvbnRyb2xsZXJWYWx1ZSA9IChldmVudCkgPT4gaXNPYmplY3QoZXZlbnQpICYmIGV2ZW50LnRhcmdldFxyXG4gICAgPyBpc0NoZWNrQm94SW5wdXQoZXZlbnQudGFyZ2V0KVxyXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcclxuICAgICAgICA6IGV2ZW50LnRhcmdldC52YWx1ZVxyXG4gICAgOiBldmVudDtcblxudmFyIGdldE5vZGVQYXJlbnROYW1lID0gKG5hbWUpID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUuc2VhcmNoKC8uXFxkLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IFsuLi5uYW1lc10uc29tZSgoY3VycmVudCkgPT4gZ2V0Tm9kZVBhcmVudE5hbWUobmFtZSkgPT09IGN1cnJlbnQpO1xuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gdmFsdWUuZmlsdGVyKEJvb2xlYW4pO1xuXG52YXIgaXNVbmRlZmluZWQgPSAodmFsKSA9PiB2YWwgPT09IHVuZGVmaW5lZDtcblxudmFyIGdldCA9IChvYmosIHBhdGgsIGRlZmF1bHRWYWx1ZSkgPT4ge1xyXG4gICAgaWYgKGlzT2JqZWN0KG9iaikgJiYgcGF0aCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhY3QocGF0aC5zcGxpdCgvWyxbXFxdLl0rPy8pKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiAoaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdFtrZXldKSwgb2JqKTtcclxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9ialxyXG4gICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9ialtwYXRoXSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXHJcbiAgICAgICAgICAgICAgICA6IG9ialtwYXRoXVxyXG4gICAgICAgICAgICA6IHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XG5cbmNvbnN0IEVWRU5UUyA9IHtcclxuICAgIEJMVVI6ICdibHVyJyxcclxuICAgIENIQU5HRTogJ2NoYW5nZScsXHJcbn07XHJcbmNvbnN0IFZBTElEQVRJT05fTU9ERSA9IHtcclxuICAgIG9uQmx1cjogJ29uQmx1cicsXHJcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcclxuICAgIG9uU3VibWl0OiAnb25TdWJtaXQnLFxyXG4gICAgb25Ub3VjaGVkOiAnb25Ub3VjaGVkJyxcclxuICAgIGFsbDogJ2FsbCcsXHJcbn07XHJcbmNvbnN0IElOUFVUX1ZBTElEQVRJT05fUlVMRVMgPSB7XHJcbiAgICBtYXg6ICdtYXgnLFxyXG4gICAgbWluOiAnbWluJyxcclxuICAgIG1heExlbmd0aDogJ21heExlbmd0aCcsXHJcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxyXG4gICAgcGF0dGVybjogJ3BhdHRlcm4nLFxyXG4gICAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXHJcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcclxufTtcblxudmFyIG9taXQgPSAoc291cmNlLCBrZXkpID0+IHtcclxuICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpO1xyXG4gICAgZGVsZXRlIGNvcHlba2V5XTtcclxuICAgIHJldHVybiBjb3B5O1xyXG59O1xuXG5jb25zdCBGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbkZvcm1Db250ZXh0LmRpc3BsYXlOYW1lID0gJ1JIRkNvbnRleHQnO1xyXG5jb25zdCB1c2VGb3JtQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRm9ybUNvbnRleHQpO1xyXG5jb25zdCBGb3JtUHJvdmlkZXIgPSAocHJvcHMpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBvbWl0KHByb3BzLCAnY2hpbGRyZW4nKSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuXG52YXIgZ2V0UHJveHlGb3JtU3RhdGUgPSAoaXNQcm94eUVuYWJsZWQsIGZvcm1TdGF0ZSwgcmVhZEZvcm1TdGF0ZVJlZiwgbG9jYWxSZWFkRm9ybVN0YXRlUmVmLCBpc1Jvb3QgPSB0cnVlKSA9PiBpc1Byb3h5RW5hYmxlZFxyXG4gICAgPyBuZXcgUHJveHkoZm9ybVN0YXRlLCB7XHJcbiAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudFtwcm9wXSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudFtwcm9wXSA9IGlzUm9vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFZBTElEQVRJT05fTU9ERS5hbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9jYWxSZWFkRm9ybVN0YXRlUmVmICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsUmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50W3Byb3BdID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgIH0pXHJcbiAgICA6IGZvcm1TdGF0ZTtcblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxudmFyIHNob3VsZFJlbmRlckZvcm1TdGF0ZSA9IChmb3JtU3RhdGVEYXRhLCByZWFkRm9ybVN0YXRlUmVmLCBpc1Jvb3QpID0+IHtcclxuICAgIGNvbnN0IGZvcm1TdGF0ZSA9IG9taXQoZm9ybVN0YXRlRGF0YSwgJ25hbWUnKTtcclxuICAgIHJldHVybiAoaXNFbXB0eU9iamVjdChmb3JtU3RhdGUpIHx8XHJcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPj0gT2JqZWN0LmtleXMocmVhZEZvcm1TdGF0ZVJlZikubGVuZ3RoIHx8XHJcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5maW5kKChrZXkpID0+IHJlYWRGb3JtU3RhdGVSZWZba2V5XSA9PT1cclxuICAgICAgICAgICAgKGlzUm9vdCA/IFZBTElEQVRJT05fTU9ERS5hbGwgOiB0cnVlKSkpO1xyXG59O1xuXG52YXIgY29udmVydFRvQXJyYXlQYXlsb2FkID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcblxudmFyIGlzV2ViID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBpc1Byb3h5RW5hYmxlZCA9IGlzV2ViID8gJ1Byb3h5JyBpbiB3aW5kb3cgOiB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgY29udHJvbCwgbmFtZSB9ID0gcHJvcHMgfHwge307XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGNvbnN0IHsgZm9ybVN0YXRlUmVmLCBzdWJqZWN0c1JlZiwgcmVhZEZvcm1TdGF0ZVJlZiB9ID0gY29udHJvbCB8fCBtZXRob2RzLmNvbnRyb2w7XHJcbiAgICBjb25zdCBuYW1lUmVmID0gUmVhY3QudXNlUmVmKG5hbWUpO1xyXG4gICAgbmFtZVJlZi5jdXJyZW50ID0gbmFtZTtcclxuICAgIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShmb3JtU3RhdGVSZWYuY3VycmVudCk7XHJcbiAgICBjb25zdCByZWFkRm9ybVN0YXRlID0gUmVhY3QudXNlUmVmKHtcclxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcclxuICAgICAgICBkaXJ0eUZpZWxkczogZmFsc2UsXHJcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxyXG4gICAgfSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZvcm1TdGF0ZVN1YnNjcmlwdGlvbiA9IHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUuc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgbmV4dDogKGZvcm1TdGF0ZSkgPT4gKCFuYW1lUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICAgICAgICAgICFmb3JtU3RhdGUubmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWVSZWYuY3VycmVudCkuaW5jbHVkZXMoZm9ybVN0YXRlLm5hbWUpKSAmJlxyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyRm9ybVN0YXRlKGZvcm1TdGF0ZSwgcmVhZEZvcm1TdGF0ZS5jdXJyZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybVN0YXRlUmVmLmN1cnJlbnQpLCBmb3JtU3RhdGUpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gZm9ybVN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gZ2V0UHJveHlGb3JtU3RhdGUoaXNQcm94eUVuYWJsZWQsIGZvcm1TdGF0ZSwgcmVhZEZvcm1TdGF0ZVJlZiwgcmVhZEZvcm1TdGF0ZSwgZmFsc2UpO1xyXG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRyb2xsZXIoeyBuYW1lLCBydWxlcywgZGVmYXVsdFZhbHVlLCBjb250cm9sLCBzaG91bGRVbnJlZ2lzdGVyLCB9KSB7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGNvbnN0IHsgZGVmYXVsdFZhbHVlc1JlZiwgcmVnaXN0ZXIsIGZpZWxkc1JlZiwgdW5yZWdpc3RlciwgbmFtZXNSZWYsIHN1YmplY3RzUmVmLCBzaG91bGRVbm1vdW50LCBpbkZpZWxkQXJyYXlBY3Rpb25SZWYsIH0gPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbDtcclxuICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0SW5wdXRTdGF0ZVZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKGZpZWxkICYmIGZpZWxkLl9mICYmICFpc1VuZGVmaW5lZChmaWVsZC5fZi52YWx1ZSlcclxuICAgICAgICA/IGZpZWxkLl9mLnZhbHVlXHJcbiAgICAgICAgOiBpc1VuZGVmaW5lZChnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKSlcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcclxuICAgICAgICAgICAgOiBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKSk7XHJcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBvbkJsdXIsIHJlZiB9ID0gcmVnaXN0ZXIobmFtZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBydWxlcyksIHsgdmFsdWUgfSkpO1xyXG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcclxuICAgICAgICBjb250cm9sOiBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbCxcclxuICAgICAgICBuYW1lLFxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVJc01vdW50ZWQobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XHJcbiAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyU3Vic2NyaXB0aW9uID0gc3ViamVjdHNSZWYuY3VycmVudC5jb250cm9sLnN1YnNjcmliZSh7XHJcbiAgICAgICAgICAgIG5leHQ6IChkYXRhKSA9PiAoIWRhdGEubmFtZSB8fCBuYW1lID09PSBkYXRhLm5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUoZ2V0KGRhdGEudmFsdWVzLCBuYW1lKSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXBkYXRlSXNNb3VudGVkKG5hbWUsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVW5tb3VudEZpZWxkID0gc2hvdWxkVW5tb3VudCB8fCBzaG91bGRVbnJlZ2lzdGVyO1xyXG4gICAgICAgICAgICBpZiAoaXNOYW1lSW5GaWVsZEFycmF5KG5hbWVzUmVmLmN1cnJlbnQuYXJyYXksIG5hbWUpXHJcbiAgICAgICAgICAgICAgICA/IHNob3VsZFVubW91bnRGaWVsZCAmJiAhaW5GaWVsZEFycmF5QWN0aW9uUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgICAgIDogc2hvdWxkVW5tb3VudEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlSXNNb3VudGVkKG5hbWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbbmFtZV0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWVsZDoge1xyXG4gICAgICAgICAgICBvbkNoYW5nZTogKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldENvbnRyb2xsZXJWYWx1ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEVWRU5UUy5DSEFOR0UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25CbHVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkJsdXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRVZFTlRTLkJMVVIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIHJlZjogKGVsbSkgPT4gZWxtICYmXHJcbiAgICAgICAgICAgICAgICByZWYoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMgJiYgZWxtLmZvY3VzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHk6IChtZXNzYWdlKSA9PiBlbG0uc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGVsbS5yZXBvcnRWYWxpZGl0eSgpLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtU3RhdGUsXHJcbiAgICAgICAgZmllbGRTdGF0ZToge1xyXG4gICAgICAgICAgICBpbnZhbGlkOiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcclxuICAgICAgICAgICAgaXNEaXJ0eTogISFnZXQoZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKSxcclxuICAgICAgICAgICAgaXNUb3VjaGVkOiAhIWdldChmb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSksXHJcbiAgICAgICAgICAgIGVycm9yOiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgQ29udHJvbGxlciA9IChwcm9wcykgPT4gcHJvcHMucmVuZGVyKHVzZUNvbnRyb2xsZXIocHJvcHMpKTtcblxudmFyIGFwcGVuZEVycm9ycyA9IChuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9ycywgdHlwZSwgbWVzc2FnZSkgPT4gdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXHJcbiAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXJyb3JzW25hbWVdKSwgeyB0eXBlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXJyb3JzW25hbWVdICYmIGVycm9yc1tuYW1lXS50eXBlcyA/IGVycm9yc1tuYW1lXS50eXBlcyA6IHt9KSksIHsgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUgfSkgfSkgOiB7fTtcblxudmFyIGlzS2V5ID0gKHZhbHVlKSA9PiAvXlxcdyokLy50ZXN0KHZhbHVlKTtcblxudmFyIHN0cmluZ1RvUGF0aCA9IChpbnB1dCkgPT4gY29tcGFjdChpbnB1dC5yZXBsYWNlKC9bXCJ8J118XFxdL2csICcnKS5zcGxpdCgvXFwufFxcWy8pKTtcblxuZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcclxuICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgY29uc3QgdGVtcFBhdGggPSBpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcclxuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRlbXBQYXRoW2luZGV4XTtcclxuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICBpc09iamVjdChvYmpWYWx1ZSkgfHwgQXJyYXkuaXNBcnJheShvYmpWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IG9ialZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW11cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn1cblxuY29uc3QgZm9jdXNGaWVsZEJ5ID0gKGZpZWxkcywgY2FsbGJhY2ssIGZpZWxkc05hbWVzKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNOYW1lcyB8fCBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzLCBrZXkpO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICBjb25zdCBfZiA9IGZpZWxkLl9mO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gb21pdChmaWVsZCwgJ19mJyk7XHJcbiAgICAgICAgICAgIGlmIChfZiAmJiBjYWxsYmFjayhfZi5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9mLnJlZi5mb2N1cyAmJiBpc1VuZGVmaW5lZChfZi5yZWYuZm9jdXMoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9mLnJlZnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZi5yZWZzWzBdLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzRmllbGRCeShjdXJyZW50LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IGdldEZpZWxkc1ZhbHVlcyA9IChmaWVsZHNSZWYsIG91dHB1dCA9IHt9KSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xyXG4gICAgICAgIGlmIChmaWVsZCAmJiAhaXNOdWxsT3JVbmRlZmluZWQob3V0cHV0KSkge1xyXG4gICAgICAgICAgICBjb25zdCBfZiA9IGZpZWxkLl9mO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gb21pdChmaWVsZCwgJ19mJyk7XHJcbiAgICAgICAgICAgIHNldChvdXRwdXQsIG5hbWUsIF9mICYmIF9mLnJlZlxyXG4gICAgICAgICAgICAgICAgPyBfZi5yZWYuZGlzYWJsZWQgfHwgKF9mLnJlZnMgJiYgX2YucmVmcy5ldmVyeSgocmVmKSA9PiByZWYuZGlzYWJsZWQpKVxyXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgOiBfZi52YWx1ZVxyXG4gICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgID8gW11cclxuICAgICAgICAgICAgICAgICAgICA6IHt9KTtcclxuICAgICAgICAgICAgY3VycmVudCAmJlxyXG4gICAgICAgICAgICAgICAgZ2V0RmllbGRzVmFsdWVzKHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgfSwgb3V0cHV0W25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xuXG52YXIgZ2VuZXJhdGVJZCA9ICgpID0+IHtcclxuICAgIGNvbnN0IGQgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZS5ub3coKSA6IHBlcmZvcm1hbmNlLm5vdygpICogMTAwMDtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XHJcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYgKyBkKSAlIDE2IHwgMDtcclxuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn07XG5cbnZhciBtYXBJZHMgPSAodmFsdWVzID0gW10sIGtleU5hbWUpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoT2JqZWN0LmFzc2lnbih7IFtrZXlOYW1lXTogKHZhbHVlICYmIHZhbHVlW2tleU5hbWVdKSB8fCBnZW5lcmF0ZUlkKCkgfSwgdmFsdWUpKSk7XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0Mikge1xyXG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdDEpIHx8XHJcbiAgICAgICAgaXNQcmltaXRpdmUob2JqZWN0MikgfHxcclxuICAgICAgICBpc0RhdGVPYmplY3Qob2JqZWN0MSkgfHxcclxuICAgICAgICBpc0RhdGVPYmplY3Qob2JqZWN0MikpIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqZWN0MSk7XHJcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xyXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcclxuICAgICAgICBjb25zdCB2YWwxID0gb2JqZWN0MVtrZXldO1xyXG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBvYmplY3QyW2tleV07XHJcbiAgICAgICAgICAgIGlmICgoaXNPYmplY3QodmFsMSkgfHwgQXJyYXkuaXNBcnJheSh2YWwxKSkgJiZcclxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwyKSB8fCBBcnJheS5pc0FycmF5KHZhbDIpKVxyXG4gICAgICAgICAgICAgICAgPyAhZGVlcEVxdWFsKHZhbDEsIHZhbDIpXHJcbiAgICAgICAgICAgICAgICA6IHZhbDEgIT09IHZhbDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKGlzUHJpbWl0aXZlKHRhcmdldCkgfHwgaXNQcmltaXRpdmUoc291cmNlKSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPVxyXG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHRhcmdldFZhbHVlKSAmJiBpc09iamVjdChzb3VyY2VWYWx1ZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpICYmIEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZGVlcE1lcmdlKHRhcmdldFZhbHVlLCBzb3VyY2VWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZVZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxuXG5mdW5jdGlvbiBzZXREaXJ0eUZpZWxkcyh2YWx1ZXMsIGRlZmF1bHRWYWx1ZXMsIGRpcnR5RmllbGRzLCBwYXJlbnROb2RlLCBwYXJlbnROYW1lKSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlc1tpbmRleF0pIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2luZGV4XVtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgIWRpcnR5RmllbGRzW2luZGV4XSAmJiAoZGlydHlGaWVsZHNbaW5kZXhdID0ge30pO1xyXG4gICAgICAgICAgICAgICAgZGlydHlGaWVsZHNbaW5kZXhdW2tleV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIHNldERpcnR5RmllbGRzKHZhbHVlc1tpbmRleF1ba2V5XSwgZ2V0KGRlZmF1bHRWYWx1ZXNbaW5kZXhdIHx8IHt9LCBrZXksIFtdKSwgZGlydHlGaWVsZHNbaW5kZXhdW2tleV0sIGRpcnR5RmllbGRzW2luZGV4XSwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICFpc051bGxPclVuZGVmaW5lZChkZWZhdWx0VmFsdWVzKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBFcXVhbChnZXQoZGVmYXVsdFZhbHVlc1tpbmRleF0gfHwge30sIGtleSksIHZhbHVlc1tpbmRleF1ba2V5XSlcclxuICAgICAgICAgICAgICAgICAgICA/IHNldChkaXJ0eUZpZWxkc1tpbmRleF0gfHwge30sIGtleSlcclxuICAgICAgICAgICAgICAgICAgICA6IChkaXJ0eUZpZWxkc1tpbmRleF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRpcnR5RmllbGRzW2luZGV4XSksIHsgW2tleV06IHRydWUgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudE5vZGUgJiZcclxuICAgICAgICAgICAgIWRpcnR5RmllbGRzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICBkZWxldGUgcGFyZW50Tm9kZVtwYXJlbnROYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaXJ0eUZpZWxkcztcclxufVxyXG52YXIgc2V0RmllbGRBcnJheURpcnR5RmllbGRzID0gKHZhbHVlcywgZGVmYXVsdFZhbHVlcywgZGlydHlGaWVsZHMpID0+IGRlZXBNZXJnZShzZXREaXJ0eUZpZWxkcyh2YWx1ZXMsIGRlZmF1bHRWYWx1ZXMsIGRpcnR5RmllbGRzLnNsaWNlKDAsIHZhbHVlcy5sZW5ndGgpKSwgc2V0RGlydHlGaWVsZHMoZGVmYXVsdFZhbHVlcywgdmFsdWVzLCBkaXJ0eUZpZWxkcy5zbGljZSgwLCB2YWx1ZXMubGVuZ3RoKSkpO1xuXG5mdW5jdGlvbiBhcHBlbmQoZGF0YSwgdmFsdWUpIHtcclxuICAgIHJldHVybiBbLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKGRhdGEpLCAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpXTtcclxufVxuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLi4uZGF0YS5zbGljZSgwLCBpbmRleCksXHJcbiAgICAgICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcclxuICAgICAgICAuLi5kYXRhLnNsaWNlKGluZGV4KSxcclxuICAgIF07XHJcbn1cblxudmFyIG1vdmVBcnJheUF0ID0gKGRhdGEsIGZyb20sIHRvKSA9PiB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhW3RvXSkpIHtcclxuICAgICAgICAgICAgZGF0YVt0b10gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGEuc3BsaWNlKHRvLCAwLCBkYXRhLnNwbGljZShmcm9tLCAxKVswXSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn07XG5cbmZ1bmN0aW9uIHByZXBlbmQoZGF0YSwgdmFsdWUpIHtcclxuICAgIHJldHVybiBbLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSwgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKGRhdGEpXTtcclxufVxuXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXhlcykge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29uc3QgdGVtcCA9IFsuLi5kYXRhXTtcclxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xyXG4gICAgICAgIHRlbXAuc3BsaWNlKGluZGV4IC0gaSwgMSk7XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xyXG59XHJcbnZhciByZW1vdmVBcnJheUF0ID0gKGRhdGEsIGluZGV4KSA9PiBpc1VuZGVmaW5lZChpbmRleClcclxuICAgID8gW11cclxuICAgIDogcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGNvbnZlcnRUb0FycmF5UGF5bG9hZChpbmRleCkuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XHJcbiAgICBkYXRhW2luZGV4QV0gPSBbZGF0YVtpbmRleEJdLCAoZGF0YVtpbmRleEJdID0gZGF0YVtpbmRleEFdKV1bMF07XHJcbn07XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdXBkYXRlUGF0aC5zbGljZSgwLCAtMSkubGVuZ3RoO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIG9iamVjdCA9IGlzVW5kZWZpbmVkKG9iamVjdCkgPyBpbmRleCsrIDogb2JqZWN0W3VwZGF0ZVBhdGhbaW5kZXgrK11dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcclxuICAgIGNvbnN0IHVwZGF0ZVBhdGggPSBpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKTtcclxuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gdXBkYXRlUGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCB1cGRhdGVQYXRoKTtcclxuICAgIGNvbnN0IGtleSA9IHVwZGF0ZVBhdGhbdXBkYXRlUGF0aC5sZW5ndGggLSAxXTtcclxuICAgIGxldCBwcmV2aW91c09ialJlZjtcclxuICAgIGlmIChjaGlsZE9iamVjdCkge1xyXG4gICAgICAgIGRlbGV0ZSBjaGlsZE9iamVjdFtrZXldO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgIGxldCBvYmplY3RSZWY7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhzID0gdXBkYXRlUGF0aC5zbGljZSgwLCAtKGsgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGhzTGVuZ3RoID0gY3VycmVudFBhdGhzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGsgPiAwKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzT2JqUmVmID0gb2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGN1cnJlbnRQYXRocy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGN1cnJlbnRQYXRoc1tpbmRleF07XHJcbiAgICAgICAgICAgIG9iamVjdFJlZiA9IG9iamVjdFJlZiA/IG9iamVjdFJlZltpdGVtXSA6IG9iamVjdFtpdGVtXTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoc0xlbmd0aCA9PT0gaW5kZXggJiZcclxuICAgICAgICAgICAgICAgICgoaXNPYmplY3Qob2JqZWN0UmVmKSAmJiBpc0VtcHR5T2JqZWN0KG9iamVjdFJlZikpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0UmVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhb2JqZWN0UmVmLmZpbHRlcigoZGF0YSkgPT4gKGlzT2JqZWN0KGRhdGEpICYmICFpc0VtcHR5T2JqZWN0KGRhdGEpKSB8fCBpc0Jvb2xlYW4oZGF0YSkpLmxlbmd0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c09ialJlZiA/IGRlbGV0ZSBwcmV2aW91c09ialJlZltpdGVtXSA6IGRlbGV0ZSBvYmplY3RbaXRlbV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXNPYmpSZWYgPSBvYmplY3RSZWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxuXG5jb25zdCB1c2VGaWVsZEFycmF5ID0gKHsgY29udHJvbCwgbmFtZSwga2V5TmFtZSA9ICdpZCcsIHNob3VsZFVucmVnaXN0ZXIsIH0pID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgZm9jdXNOYW1lUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcclxuICAgIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XHJcbiAgICBjb25zdCB7IGdldElzRGlydHksIG5hbWVzUmVmLCBmaWVsZHNSZWYsIGRlZmF1bHRWYWx1ZXNSZWYsIGZvcm1TdGF0ZVJlZiwgc3ViamVjdHNSZWYsIHJlYWRGb3JtU3RhdGVSZWYsIHVwZGF0ZUlzVmFsaWQsIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLCB1bnJlZ2lzdGVyLCBzaG91bGRVbm1vdW50LCBpbkZpZWxkQXJyYXlBY3Rpb25SZWYsIHNldFZhbHVlcywgcmVnaXN0ZXIsIH0gPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbDtcclxuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShtYXBJZHMoKGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSkgJiYgaXNNb3VudGVkUmVmLmN1cnJlbnRcclxuICAgICAgICA/IGdldChnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmKSwgbmFtZSlcclxuICAgICAgICA6IGdldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBnZXROb2RlUGFyZW50TmFtZShuYW1lKSlcclxuICAgICAgICAgICAgPyBnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICAgICAgOiBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKSkgfHwgW10sIGtleU5hbWUpKTtcclxuICAgIHNldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lLCBbLi4uZmllbGRzXSk7XHJcbiAgICBuYW1lc1JlZi5jdXJyZW50LmFycmF5LmFkZChuYW1lKTtcclxuICAgIGNvbnN0IG9taXRLZXkgPSAoZmllbGRzKSA9PiBmaWVsZHMubWFwKChmaWVsZCA9IHt9KSA9PiBvbWl0KGZpZWxkLCBrZXlOYW1lKSk7XHJcbiAgICBjb25zdCBnZXRDdXJyZW50RmllbGRzVmFsdWVzID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGdldChnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmKSwgbmFtZSwgW10pO1xyXG4gICAgICAgIHJldHVybiBtYXBJZHMoZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKS5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgdmFsdWVzW2luZGV4XSkpKSwga2V5TmFtZSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0Rm9jdXNGaWVsZE5hbWUgPSAoaW5kZXgsIG9wdGlvbnMpID0+IG9wdGlvbnMgJiYgIW9wdGlvbnMuc2hvdWxkRm9jdXNcclxuICAgICAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8IGAke25hbWV9LiR7b3B0aW9ucy5mb2N1c0luZGV4fS5gXHJcbiAgICAgICAgOiBgJHtuYW1lfS4ke2luZGV4fS5gO1xyXG4gICAgY29uc3Qgc2V0RmllbGRzQW5kTm90aWZ5ID0gKGZpZWxkc1ZhbHVlcyA9IFtdKSA9PiBzZXRGaWVsZHMobWFwSWRzKGZpZWxkc1ZhbHVlcywga2V5TmFtZSkpO1xyXG4gICAgY29uc3QgY2xlYW51cCA9IChyZWYpID0+ICFjb21wYWN0KGdldChyZWYsIG5hbWUsIFtdKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XHJcbiAgICBjb25zdCBiYXRjaFN0YXRlVXBkYXRlID0gKG1ldGhvZCwgYXJncywgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBbXSwgc2hvdWxkU2V0ID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgIGluRmllbGRBcnJheUFjdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBtZXRob2QoZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xyXG4gICAgICAgICAgICBzaG91bGRTZXQgJiYgc2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCBvdXRwdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gbWV0aG9kKGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XHJcbiAgICAgICAgICAgIHNob3VsZFNldCAmJiBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lLCBvdXRwdXQpO1xyXG4gICAgICAgICAgICBjbGVhbnVwKGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZEZpZWxkcyAmJlxyXG4gICAgICAgICAgICBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZEZpZWxkcywgbmFtZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gbWV0aG9kKGdldChmb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkRmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xyXG4gICAgICAgICAgICBzaG91bGRTZXQgJiYgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHMsIG5hbWUsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIGNsZWFudXAoZm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZEZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpIHtcclxuICAgICAgICAgICAgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBzZXRGaWVsZEFycmF5RGlydHlGaWVsZHMob21pdEtleSh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyksIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSwgZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBbXSkpKTtcclxuICAgICAgICAgICAgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgJiZcclxuICAgICAgICAgICAgICAgIHNldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSwgc2V0RmllbGRBcnJheURpcnR5RmllbGRzKG9taXRLZXkodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpLCBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lLCBbXSksIGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSwgW10pKSk7XHJcbiAgICAgICAgICAgIGNsZWFudXAoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogZm9ybVN0YXRlUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgICAgIC5kaXJ0eUZpZWxkcyxcclxuICAgICAgICAgICAgaXNEaXJ0eTogZ2V0SXNEaXJ0eShuYW1lLCBvbWl0S2V5KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKSksXHJcbiAgICAgICAgICAgIGVycm9yczogZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlZ2lzdGVyRmllbGRBcnJheSA9ICh2YWx1ZXMsIGluZGV4ID0gMCwgcGFyZW50TmFtZSA9ICcnKSA9PiB2YWx1ZXMuZm9yRWFjaCgoYXBwZW5kVmFsdWVJdGVtLCB2YWx1ZUluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBgJHtwYXJlbnROYW1lIHx8IG5hbWV9LiR7cGFyZW50TmFtZSA/IHZhbHVlSW5kZXggOiBpbmRleCArIHZhbHVlSW5kZXh9YDtcclxuICAgICAgICBpc1ByaW1pdGl2ZShhcHBlbmRWYWx1ZUl0ZW0pXHJcbiAgICAgICAgICAgID8gcmVnaXN0ZXIocm9vdE5hbWUsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcHBlbmRWYWx1ZUl0ZW0sXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogT2JqZWN0LmVudHJpZXMoYXBwZW5kVmFsdWVJdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0TmFtZSA9IHJvb3ROYW1lICsgJy4nICsga2V5O1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IHJlZ2lzdGVyRmllbGRBcnJheSh2YWx1ZSwgdmFsdWVJbmRleCwgaW5wdXROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVnaXN0ZXIoaW5wdXROYW1lLCB7IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYXBwZW5kJDEgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBjb25zdCBhcHBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBhcHBlbmQoZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcygpLCBhcHBlbmRWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubGVuZ3RoIC0gYXBwZW5kVmFsdWUubGVuZ3RoO1xyXG4gICAgICAgIHNldEZpZWxkc0FuZE5vdGlmeSh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XHJcbiAgICAgICAgYmF0Y2hTdGF0ZVVwZGF0ZShhcHBlbmQsIHtcclxuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxyXG4gICAgICAgIH0sIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBmYWxzZSk7XHJcbiAgICAgICAgcmVnaXN0ZXJGaWVsZEFycmF5KGFwcGVuZFZhbHVlLCBjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgIGZvY3VzTmFtZVJlZi5jdXJyZW50ID0gZ2V0Rm9jdXNGaWVsZE5hbWUoY3VycmVudEluZGV4LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcmVwZW5kJDEgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBjb25zdCBwcmVwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcHJlcGVuZChnZXRDdXJyZW50RmllbGRzVmFsdWVzKCksIHByZXBlbmRWYWx1ZSk7XHJcbiAgICAgICAgc2V0RmllbGRzQW5kTm90aWZ5KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcclxuICAgICAgICBiYXRjaFN0YXRlVXBkYXRlKHByZXBlbmQsIHtcclxuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxyXG4gICAgICAgIH0sIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcclxuICAgICAgICByZWdpc3RlckZpZWxkQXJyYXkocHJlcGVuZFZhbHVlKTtcclxuICAgICAgICBmb2N1c05hbWVSZWYuY3VycmVudCA9IGdldEZvY3VzRmllbGROYW1lKDAsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gcmVtb3ZlQXJyYXlBdChnZXRDdXJyZW50RmllbGRzVmFsdWVzKCksIGluZGV4KTtcclxuICAgICAgICBzZXRGaWVsZHNBbmROb3RpZnkodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xyXG4gICAgICAgIGJhdGNoU3RhdGVVcGRhdGUocmVtb3ZlQXJyYXlBdCwge1xyXG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcclxuICAgICAgICB9LCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0KGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKSwgaW5kZXgsIGluc2VydFZhbHVlKTtcclxuICAgICAgICBzZXRGaWVsZHNBbmROb3RpZnkodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xyXG4gICAgICAgIGJhdGNoU3RhdGVVcGRhdGUoaW5zZXJ0LCB7XHJcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxyXG4gICAgICAgICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgfSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xyXG4gICAgICAgIHJlZ2lzdGVyRmllbGRBcnJheShpbnNlcnRWYWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgIGZvY3VzTmFtZVJlZi5jdXJyZW50ID0gZ2V0Rm9jdXNGaWVsZE5hbWUoaW5kZXgsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHN3YXAgPSAoaW5kZXhBLCBpbmRleEIpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKTtcclxuICAgICAgICBzd2FwQXJyYXlBdChmaWVsZFZhbHVlcywgaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICAgIGJhdGNoU3RhdGVVcGRhdGUoc3dhcEFycmF5QXQsIHtcclxuICAgICAgICAgICAgYXJnQTogaW5kZXhBLFxyXG4gICAgICAgICAgICBhcmdCOiBpbmRleEIsXHJcbiAgICAgICAgfSwgZmllbGRWYWx1ZXMsIGZhbHNlKTtcclxuICAgICAgICBzZXRGaWVsZHNBbmROb3RpZnkoZmllbGRWYWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKTtcclxuICAgICAgICBtb3ZlQXJyYXlBdChmaWVsZFZhbHVlcywgZnJvbSwgdG8pO1xyXG4gICAgICAgIHNldEZpZWxkc0FuZE5vdGlmeShmaWVsZFZhbHVlcyk7XHJcbiAgICAgICAgYmF0Y2hTdGF0ZVVwZGF0ZShtb3ZlQXJyYXlBdCwge1xyXG4gICAgICAgICAgICBhcmdBOiBmcm9tLFxyXG4gICAgICAgICAgICBhcmdCOiB0byxcclxuICAgICAgICB9LCBmaWVsZFZhbHVlcywgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZSA9IChpbmRleCwgdmFsdWUpID0+IHtcclxuICAgICAgICBzZXRWYWx1ZXMoKG5hbWUgKyAnLicgKyBpbmRleCksIHZhbHVlLCB7XHJcbiAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlOiAhIXJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkLFxyXG4gICAgICAgICAgICBzaG91bGREaXJ0eTogISEocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzIHx8XHJcbiAgICAgICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRDdXJyZW50RmllbGRzVmFsdWVzKCk7XHJcbiAgICAgICAgZmllbGRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgc2V0RmllbGRzQW5kTm90aWZ5KGZpZWxkVmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGluRmllbGRBcnJheUFjdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG5hbWVzUmVmLmN1cnJlbnQud2F0Y2hBbGwpIHtcclxuICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd2F0Y2hGaWVsZCBvZiBuYW1lc1JlZi5jdXJyZW50LndhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKHdhdGNoRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHt9KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LndhdGNoLm5leHQoe1xyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICB2YWx1ZXM6IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvY3VzTmFtZVJlZi5jdXJyZW50ICYmXHJcbiAgICAgICAgICAgIGZvY3VzRmllbGRCeShmaWVsZHNSZWYuY3VycmVudCwgKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoZm9jdXNOYW1lUmVmLmN1cnJlbnQpKTtcclxuICAgICAgICBmb2N1c05hbWVSZWYuY3VycmVudCA9ICcnO1xyXG4gICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuYXJyYXkubmV4dCh7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHZhbHVlczogb21pdEtleShbLi4uZmllbGRzXSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdXBkYXRlSXNWYWxpZCgpO1xyXG4gICAgfSwgW2ZpZWxkcywgbmFtZV0pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZEFycmF5U3Vic2NyaXB0aW9uID0gc3ViamVjdHNSZWYuY3VycmVudC5hcnJheS5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICBuZXh0KHsgbmFtZTogaW5wdXRGaWVsZEFycmF5TmFtZSwgdmFsdWVzLCBpc1Jlc2V0IH0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoZmllbGRzUmVmLmN1cnJlbnQsIGlucHV0RmllbGRBcnJheU5hbWUgfHwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRGaWVsZEFycmF5TmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBpbnB1dEZpZWxkQXJyYXlOYW1lLCB2YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQgPSB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZpZWxkc0FuZE5vdGlmeShnZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICFnZXQoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpICYmIHNldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgW10pO1xyXG4gICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBmaWVsZEFycmF5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRVbm1vdW50IHx8IHNob3VsZFVucmVnaXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB1bnNldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkQXJyYXlWYWx1ZXMgPSBnZXQoZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZiksIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZmllbGRBcnJheVZhbHVlcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lLCBmaWVsZEFycmF5VmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFtuYW1lXSksXHJcbiAgICAgICAgbW92ZTogUmVhY3QudXNlQ2FsbGJhY2sobW92ZSwgW25hbWVdKSxcclxuICAgICAgICBwcmVwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhwcmVwZW5kJDEsIFtuYW1lXSksXHJcbiAgICAgICAgYXBwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhhcHBlbmQkMSwgW25hbWVdKSxcclxuICAgICAgICByZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKHJlbW92ZSwgW25hbWVdKSxcclxuICAgICAgICBpbnNlcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGluc2VydCQxLCBbbmFtZV0pLFxyXG4gICAgICAgIHVwZGF0ZTogUmVhY3QudXNlQ2FsbGJhY2sodXBkYXRlLCBbbmFtZV0pLFxyXG4gICAgICAgIGZpZWxkczogZmllbGRzLFxyXG4gICAgfTtcclxufTtcblxudmFyIGlzRmlsZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xuXG52YXIgaXNNdWx0aXBsZVNlbGVjdCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09IGBzZWxlY3QtbXVsdGlwbGVgO1xuXG52YXIgaXNSYWRpb0lucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ3JhZGlvJztcblxuY29uc3QgZGVmYXVsdFJlc3VsdCA9IHtcclxuICAgIHZhbHVlOiBmYWxzZSxcclxuICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG59O1xyXG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcclxudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZXMsIGlzVmFsaWQ6ICEhdmFsdWVzLmxlbmd0aCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXHJcbiAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCB0byB3b3JrIGluIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLmF0dHJpYnV0ZXMgJiYgIWlzVW5kZWZpbmVkKG9wdGlvbnNbMF0uYXR0cmlidXRlcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHZhbHVlOiBvcHRpb25zWzBdLnZhbHVlLCBpc1ZhbGlkOiB0cnVlIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XHJcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xyXG59O1xuXG52YXIgZ2V0RmllbGRWYWx1ZUFzID0gKHZhbHVlLCB7IHZhbHVlQXNOdW1iZXIsIHZhbHVlQXNEYXRlLCBzZXRWYWx1ZUFzIH0pID0+IGlzVW5kZWZpbmVkKHZhbHVlKVxyXG4gICAgPyB2YWx1ZVxyXG4gICAgOiB2YWx1ZUFzTnVtYmVyXHJcbiAgICAgICAgPyB2YWx1ZSA9PT0gJydcclxuICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgOiArdmFsdWVcclxuICAgICAgICA6IHZhbHVlQXNEYXRlXHJcbiAgICAgICAgICAgID8gbmV3IERhdGUodmFsdWUpXHJcbiAgICAgICAgICAgIDogc2V0VmFsdWVBc1xyXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgOiB2YWx1ZTtcblxudmFyIGdldE11bHRpcGxlU2VsZWN0VmFsdWUgPSAob3B0aW9ucykgPT4gWy4uLm9wdGlvbnNdXHJcbiAgICAuZmlsdGVyKCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKVxyXG4gICAgLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm4gPSB7XHJcbiAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgIHZhbHVlOiBudWxsLFxyXG59O1xyXG52YXIgZ2V0UmFkaW9WYWx1ZSA9IChvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KG9wdGlvbnMpXHJcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZFxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHByZXZpb3VzLCBkZWZhdWx0UmV0dXJuKVxyXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKGZpZWxkKSB7XHJcbiAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcclxuICAgICAgICBjb25zdCByZWYgPSBmaWVsZC5fZi5yZWY7XHJcbiAgICAgICAgaWYgKHJlZi5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYuZmlsZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShmaWVsZC5fZi5yZWZzKS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TXVsdGlwbGVTZWxlY3RWYWx1ZShyZWYub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShmaWVsZC5fZi5yZWZzKS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gZmllbGQuX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBmaWVsZC5fZik7XHJcbiAgICB9XHJcbn1cblxudmFyIGdldFJlc29sdmVyT3B0aW9ucyA9IChmaWVsZHNOYW1lcywgZmllbGRzUmVmcywgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSA9PiB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSB7fTtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZnMsIG5hbWUpO1xyXG4gICAgICAgIGZpZWxkICYmIHNldChmaWVsZHMsIG5hbWUsIGZpZWxkLl9mKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY3JpdGVyaWFNb2RlLFxyXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxyXG4gICAgICAgIGZpZWxkcyxcclxuICAgICAgICBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLFxyXG4gICAgfTtcclxufTtcblxudmFyIGhhc1ZhbGlkYXRpb24gPSAob3B0aW9ucywgbW91bnRlZCkgPT4gbW91bnRlZCAmJlxyXG4gICAgb3B0aW9ucyAmJlxyXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcclxuICAgICAgICBvcHRpb25zLm1pbiB8fFxyXG4gICAgICAgIG9wdGlvbnMubWF4IHx8XHJcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcclxuICAgICAgICBvcHRpb25zLm1pbkxlbmd0aCB8fFxyXG4gICAgICAgIG9wdGlvbnMucGF0dGVybiB8fFxyXG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoeyBpc09uQmx1ciwgaXNPbkNoYW5nZSwgaXNPblRvdWNoLCBpc1RvdWNoZWQsIGlzUmVWYWxpZGF0ZU9uQmx1ciwgaXNSZVZhbGlkYXRlT25DaGFuZ2UsIGlzQmx1ckV2ZW50LCBpc1N1Ym1pdHRlZCwgaXNPbkFsbCwgfSkgPT4ge1xyXG4gICAgaWYgKGlzT25BbGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgaXNPblRvdWNoKSB7XHJcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3VibWl0dGVkID8gaXNSZVZhbGlkYXRlT25CbHVyIDogaXNPbkJsdXIpIHtcclxuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyBpc1JlVmFsaWRhdGVPbkNoYW5nZSA6IGlzT25DaGFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gaXNCbHVyRXZlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgaXNNZXNzYWdlID0gKHZhbHVlKSA9PiBpc1N0cmluZyh2YWx1ZSkgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQodmFsdWUpO1xuXG52YXIgaXNSZWdleCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XHJcbiAgICBpZiAoaXNNZXNzYWdlKHJlc3VsdCkgfHxcclxuICAgICAgICAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5ldmVyeShpc01lc3NhZ2UpKSB8fFxyXG4gICAgICAgIChpc0Jvb2xlYW4ocmVzdWx0KSAmJiAhcmVzdWx0KSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzTWVzc2FnZShyZXN1bHQpID8gcmVzdWx0IDogJycsXHJcbiAgICAgICAgICAgIHJlZixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBnZXRWYWx1ZUFuZE1lc3NhZ2UgPSAodmFsaWRhdGlvbkRhdGEpID0+IGlzT2JqZWN0KHZhbGlkYXRpb25EYXRhKSAmJiAhaXNSZWdleCh2YWxpZGF0aW9uRGF0YSlcclxuICAgID8gdmFsaWRhdGlvbkRhdGFcclxuICAgIDoge1xyXG4gICAgICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcclxuICAgICAgICBtZXNzYWdlOiAnJyxcclxuICAgIH07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKHsgX2Y6IHsgcmVmLCByZWZzLCByZXF1aXJlZCwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4LCBwYXR0ZXJuLCB2YWxpZGF0ZSwgbmFtZSwgdmFsdWU6IGlucHV0VmFsdWUsIHZhbHVlQXNOdW1iZXIsIG1vdW50LCB9LCB9LCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pID0+IHtcclxuICAgIGlmICghbW91bnQpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dFJlZiA9IHJlZnMgPyByZWZzWzBdIDogcmVmO1xyXG4gICAgY29uc3Qgc2V0Q3VzdG9tVmFsaWR0eSA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgaWYgKHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkpIHtcclxuICAgICAgICAgICAgaW5wdXRSZWYuc2V0Q3VzdG9tVmFsaWRpdHkoaXNCb29sZWFuKG1lc3NhZ2UpID8gJycgOiBtZXNzYWdlIHx8ICcgJyk7XHJcbiAgICAgICAgICAgIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGVycm9yID0ge307XHJcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc0NoZWNrQm94ID0gaXNDaGVja0JveElucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcclxuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiYgIXJlZi52YWx1ZSkgfHxcclxuICAgICAgICBpbnB1dFZhbHVlID09PSAnJyB8fFxyXG4gICAgICAgIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlLmxlbmd0aCk7XHJcbiAgICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKG51bGwsIG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3IpO1xyXG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4Y2VlZE1heCA/IG1heExlbmd0aE1lc3NhZ2UgOiBtaW5MZW5ndGhNZXNzYWdlO1xyXG4gICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLCBtZXNzYWdlLFxyXG4gICAgICAgICAgICByZWYgfSwgYXBwZW5kRXJyb3JzQ3VycnkoZXhjZWVkTWF4ID8gbWF4VHlwZSA6IG1pblR5cGUsIG1lc3NhZ2UpKTtcclxuICAgIH07XHJcbiAgICBpZiAocmVxdWlyZWQgJiZcclxuICAgICAgICAoKCFpc1JhZGlvT3JDaGVja2JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSkpIHx8XHJcbiAgICAgICAgICAgIChpc0Jvb2xlYW4oaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUpIHx8XHJcbiAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XHJcbiAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKHJlZnMpLmlzVmFsaWQpKSkge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1lc3NhZ2UgfSA9IGlzTWVzc2FnZShyZXF1aXJlZClcclxuICAgICAgICAgICAgPyB7IHZhbHVlOiAhIXJlcXVpcmVkLCBtZXNzYWdlOiByZXF1aXJlZCB9XHJcbiAgICAgICAgICAgIDogZ2V0VmFsdWVBbmRNZXNzYWdlKHJlcXVpcmVkKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSBPYmplY3QuYXNzaWduKHsgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSwgcmVmOiBpbnB1dFJlZiB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCBtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZHR5KG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcclxuICAgICAgICBsZXQgZXhjZWVkTWF4O1xyXG4gICAgICAgIGxldCBleGNlZWRNaW47XHJcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XHJcbiAgICAgICAgY29uc3QgbWluT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbik7XHJcbiAgICAgICAgaWYgKCFpc05hTihpbnB1dFZhbHVlKSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU51bWJlciA9IHJlZi52YWx1ZUFzTnVtYmVyIHx8IHBhcnNlRmxvYXQoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVOdW1iZXIgPiBtYXhPdXRwdXQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5PdXRwdXQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZU51bWJlciA8IG1pbk91dHB1dC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWF4T3V0cHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWF4ID0gdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gdmFsdWVEYXRlIDwgbmV3IERhdGUobWluT3V0cHV0LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xyXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhPdXRwdXQubWVzc2FnZSwgbWluT3V0cHV0Lm1lc3NhZ2UsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4LCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbik7XHJcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZHR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJiAhaXNFbXB0eSAmJiBpc1N0cmluZyhpbnB1dFZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IG1heExlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXhMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGV4Y2VlZE1heCA9ICFpc051bGxPclVuZGVmaW5lZChtYXhMZW5ndGhPdXRwdXQudmFsdWUpICYmXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUubGVuZ3RoID4gbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhPdXRwdXQudmFsdWUpICYmXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xyXG4gICAgICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XHJcbiAgICAgICAgICAgIGdldE1pbk1heE1lc3NhZ2UoZXhjZWVkTWF4LCBtYXhMZW5ndGhPdXRwdXQubWVzc2FnZSwgbWluTGVuZ3RoT3V0cHV0Lm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWR0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcGF0dGVyblZhbHVlLCBtZXNzYWdlIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UocGF0dGVybik7XHJcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5tYXRjaChwYXR0ZXJuVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucGF0dGVybiwgbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIHJlZiB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkdHkobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWRhdGUpIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGUoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgaW5wdXRSZWYpO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRlRXJyb3IpLCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnZhbGlkYXRlLCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWR0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWxpZGF0ZSkpIHtcclxuICAgICAgICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUpLCBpbnB1dFJlZiwga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdGVFcnJvciksIGFwcGVuZEVycm9yc0N1cnJ5KGtleSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWR0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHJlZjogaW5wdXRSZWYgfSwgdmFsaWRhdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldEN1c3RvbVZhbGlkdHkodHJ1ZSk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn07XG5cbnZhciBkZWJvdW5jZSA9IChjYWxsYmFjaywgd2FpdCkgPT4ge1xyXG4gICAgbGV0IHRpbWVyID0gMDtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKC4uLmFyZ3MpLCB3YWl0KTtcclxuICAgIH07XHJcbn07XG5cbnZhciBnZXRWYWxpZGF0aW9uTW9kZXMgPSAobW9kZSkgPT4gKHtcclxuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcclxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxyXG4gICAgaXNPbkNoYW5nZTogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxyXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcclxuICAgIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZCxcclxufSk7XG5cbnZhciBpc0hUTUxFbGVtZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuXG52YXIgaXNSYWRpb09yQ2hlY2tib3hGdW5jdGlvbiA9IChyZWYpID0+IGlzUmFkaW9JbnB1dChyZWYpIHx8IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuXG5jbGFzcyBTdWJzY3JpcHRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50ZWFyRG93bnMgPSBbXTtcclxuICAgIH1cclxuICAgIGFkZCh0ZWFyRG93bikge1xyXG4gICAgICAgIHRoaXMudGVhckRvd25zLnB1c2godGVhckRvd24pO1xyXG4gICAgfVxyXG4gICAgdW5zdWJzY3JpYmUoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZWFyZG93biBvZiB0aGlzLnRlYXJEb3ducykge1xyXG4gICAgICAgICAgICB0ZWFyZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRlYXJEb3ducyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFN1YnNjcmliZXIge1xyXG4gICAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoKCkgPT4gKHRoaXMuY2xvc2VkID0gdHJ1ZSkpO1xyXG4gICAgfVxyXG4gICAgbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5uZXh0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU3ViamVjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgbmV4dCh2YWx1ZSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3Vic2NyaWJlKG9ic2VydmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihvYnNlcnZlciwgc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xyXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICB1bnN1YnNjcmliZSgpIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzV2luZG93VW5kZWZpbmVkID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XHJcbmZ1bmN0aW9uIHVzZUZvcm0oeyBtb2RlID0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LCByZVZhbGlkYXRlTW9kZSA9IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSwgcmVzb2x2ZXIsIGNvbnRleHQsIGRlZmF1bHRWYWx1ZXMgPSB7fSwgc2hvdWxkRm9jdXNFcnJvciA9IHRydWUsIGRlbGF5RXJyb3IsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIHNob3VsZFVucmVnaXN0ZXIsIGNyaXRlcmlhTW9kZSwgfSA9IHt9KSB7XHJcbiAgICBjb25zdCBbZm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxyXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxyXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcclxuICAgICAgICBzdWJtaXRDb3VudDogMCxcclxuICAgICAgICB0b3VjaGVkRmllbGRzOiB7fSxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgZXJyb3JzOiB7fSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVhZEZvcm1TdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZih7XHJcbiAgICAgICAgaXNEaXJ0eTogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIGRpcnR5RmllbGRzOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgdG91Y2hlZEZpZWxkczogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIGlzVmFsaWRhdGluZzogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIGlzVmFsaWQ6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBlcnJvcnM6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVzb2x2ZXJSZWYgPSBSZWFjdC51c2VSZWYocmVzb2x2ZXIpO1xyXG4gICAgY29uc3QgZm9ybVN0YXRlUmVmID0gUmVhY3QudXNlUmVmKGZvcm1TdGF0ZSk7XHJcbiAgICBjb25zdCBmaWVsZHNSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xyXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlc1JlZiA9IFJlYWN0LnVzZVJlZihkZWZhdWx0VmFsdWVzKTtcclxuICAgIGNvbnN0IGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IGNvbnRleHRSZWYgPSBSZWFjdC51c2VSZWYoY29udGV4dCk7XHJcbiAgICBjb25zdCBpbkZpZWxkQXJyYXlBY3Rpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IF9kZWxheUNhbGxiYWNrID0gUmVhY3QudXNlUmVmKCk7XHJcbiAgICBjb25zdCBzdWJqZWN0c1JlZiA9IFJlYWN0LnVzZVJlZih7XHJcbiAgICAgICAgd2F0Y2g6IG5ldyBTdWJqZWN0KCksXHJcbiAgICAgICAgY29udHJvbDogbmV3IFN1YmplY3QoKSxcclxuICAgICAgICBhcnJheTogbmV3IFN1YmplY3QoKSxcclxuICAgICAgICBzdGF0ZTogbmV3IFN1YmplY3QoKSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbmFtZXNSZWYgPSBSZWFjdC51c2VSZWYoe1xyXG4gICAgICAgIG1vdW50OiBuZXcgU2V0KCksXHJcbiAgICAgICAgdW5Nb3VudDogbmV3IFNldCgpLFxyXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXHJcbiAgICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcclxuICAgICAgICB3YXRjaEFsbDogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlID0gZ2V0VmFsaWRhdGlvbk1vZGVzKG1vZGUpO1xyXG4gICAgY29uc3QgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEgPSBjcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XHJcbiAgICByZXNvbHZlclJlZi5jdXJyZW50ID0gcmVzb2x2ZXI7XHJcbiAgICBjb250ZXh0UmVmLmN1cnJlbnQgPSBjb250ZXh0O1xyXG4gICAgY29uc3QgaXNGaWVsZFdhdGNoZWQgPSAobmFtZSkgPT4gbmFtZXNSZWYuY3VycmVudC53YXRjaEFsbCB8fFxyXG4gICAgICAgIG5hbWVzUmVmLmN1cnJlbnQud2F0Y2guaGFzKG5hbWUpIHx8XHJcbiAgICAgICAgbmFtZXNSZWYuY3VycmVudC53YXRjaC5oYXMoKG5hbWUubWF0Y2goL1xcdysvKSB8fCBbXSlbMF0pO1xyXG4gICAgY29uc3QgdXBkYXRlRXJyb3JTdGF0ZSA9IChuYW1lLCBlcnJvcikgPT4ge1xyXG4gICAgICAgIHNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUsIGVycm9yKTtcclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICBlcnJvcnM6IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCYXNlT25WYWxpZCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmFsaWRhdGVGb3JtKGZpZWxkc1JlZi5jdXJyZW50LCB0cnVlKTtcclxuICAgICAgICBpZiAoaXNWYWxpZCAhPT0gZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkID0gaXNWYWxpZDtcclxuICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCYXNlT25FcnJvciA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChzaG91bGRTa2lwUmVuZGVyLCBuYW1lLCBlcnJvciwgZmllbGRTdGF0ZSwgaXNWYWxpZEZyb21SZXNvbHZlciwgaXNXYXRjaGVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvciA9IGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZFxyXG4gICAgICAgICAgICA/IHJlc29sdmVyXHJcbiAgICAgICAgICAgICAgICA/IGlzVmFsaWRGcm9tUmVzb2x2ZXJcclxuICAgICAgICAgICAgICAgIDogc2hvdWxkUmVuZGVyQmFzZU9uVmFsaWQoKVxyXG4gICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgIGlmIChkZWxheUVycm9yICYmIGVycm9yKSB7XHJcbiAgICAgICAgICAgIF9kZWxheUNhbGxiYWNrLmN1cnJlbnQgPVxyXG4gICAgICAgICAgICAgICAgX2RlbGF5Q2FsbGJhY2suY3VycmVudCB8fCBkZWJvdW5jZSh1cGRhdGVFcnJvclN0YXRlLCBkZWxheUVycm9yKTtcclxuICAgICAgICAgICAgX2RlbGF5Q2FsbGJhY2suY3VycmVudChuYW1lLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgPyBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lLCBlcnJvcilcclxuICAgICAgICAgICAgICAgIDogdW5zZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChpc1dhdGNoZWQgfHxcclxuICAgICAgICAgICAgKGVycm9yID8gIWRlZXBFcXVhbChwcmV2aW91c0Vycm9yLCBlcnJvcikgOiBwcmV2aW91c0Vycm9yKSB8fFxyXG4gICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fFxyXG4gICAgICAgICAgICBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkICE9PSBpc1ZhbGlkKSAmJlxyXG4gICAgICAgICAgICAhc2hvdWxkU2tpcFJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkU3RhdGUpLCAocmVzb2x2ZXIgPyB7IGlzVmFsaWQ6ICEhaXNWYWxpZCB9IDoge30pKSwgeyBlcnJvcnM6IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgbmFtZSB9KTtcclxuICAgICAgICAgICAgZm9ybVN0YXRlUmVmLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1TdGF0ZVJlZi5jdXJyZW50KSwgdXBkYXRlZEZvcm1TdGF0ZSk7XHJcbiAgICAgICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dChpc1dhdGNoZWQgPyB7IG5hbWUgfSA6IHVwZGF0ZWRGb3JtU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuYW1lLCByYXdWYWx1ZSwgb3B0aW9ucyA9IHt9LCBzaG91bGRSZW5kZXIsIHNob3VsZFJlZ2lzdGVyKSA9PiB7XHJcbiAgICAgICAgc2hvdWxkUmVnaXN0ZXIgJiYgcmVnaXN0ZXIobmFtZSk7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICBjb25zdCBfZiA9IGZpZWxkLl9mO1xyXG4gICAgICAgICAgICBpZiAoX2YpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaXNXZWIgJiYgaXNIVE1MRWxlbWVudChfZi5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHJhd1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgICAgICAgICA6IHJhd1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX2YudmFsdWUgPSBnZXRGaWVsZFZhbHVlQXMocmF3VmFsdWUsIF9mKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JhZGlvSW5wdXQoX2YucmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChfZi5yZWZzIHx8IFtdKS5mb3JFYWNoKChyYWRpb1JlZikgPT4gKHJhZGlvUmVmLmNoZWNrZWQgPSByYWRpb1JlZi52YWx1ZSA9PT0gdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlsZUlucHV0KF9mLnJlZikgJiYgIWlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mLnJlZi5maWxlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNdWx0aXBsZVNlbGVjdChfZi5yZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgWy4uLl9mLnJlZi5vcHRpb25zXS5mb3JFYWNoKChzZWxlY3RSZWYpID0+IChzZWxlY3RSZWYuc2VsZWN0ZWQgPSB2YWx1ZS5pbmNsdWRlcyhzZWxlY3RSZWYudmFsdWUpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0NoZWNrQm94SW5wdXQoX2YucmVmKSAmJiBfZi5yZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2YucmVmcy5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2YucmVmcy5mb3JFYWNoKChjaGVja2JveFJlZikgPT4gKGNoZWNrYm94UmVmLmNoZWNrZWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhIXZhbHVlLmZpbmQoKGRhdGEpID0+IGRhdGEgPT09IGNoZWNrYm94UmVmLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChfZi5yZWZzWzBdLmNoZWNrZWQgPSAhIXZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mLnJlZi52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZXMsIG5hbWUsIHJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LmNvbnRyb2wubmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpLCB2YWx1ZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5U3RhdGUobmFtZSwgdmFsdWUsIG9wdGlvbnMuc2hvdWxkVG91Y2gpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRWYWxpZGF0ZSAmJiB0cmlnZ2VyKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmllbGQuX2YgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByYXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByYXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBnZXRJc0RpcnR5ID0gUmVhY3QudXNlQ2FsbGJhY2soKG5hbWUsIGRhdGEpID0+IHtcclxuICAgICAgICBjb25zdCBmb3JtVmFsdWVzID0gZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZik7XHJcbiAgICAgICAgbmFtZSAmJiBkYXRhICYmIHNldChmb3JtVmFsdWVzLCBuYW1lLCBkYXRhKTtcclxuICAgICAgICByZXR1cm4gIWRlZXBFcXVhbChmb3JtVmFsdWVzLCBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgdXBkYXRlVG91Y2hBbmREaXJ0eVN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKG5hbWUsIGlucHV0VmFsdWUsIGlzQ3VycmVudFRvdWNoZWQsIHNob3VsZFJlbmRlciA9IHRydWUpID0+IHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJc0RpcnR5ID0gZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eTtcclxuICAgICAgICAgICAgZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSA9IGdldElzRGlydHkoKTtcclxuICAgICAgICAgICAgc3RhdGUuaXNEaXJ0eSA9IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHk7XHJcbiAgICAgICAgICAgIGlzQ2hhbmdlZCA9IHByZXZpb3VzSXNEaXJ0eSAhPT0gc3RhdGUuaXNEaXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcyAmJiAhaXNDdXJyZW50VG91Y2hlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1ByZXZpb3VzRmllbGREaXJ0eSA9IGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcywgbmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkRGlydHkgPSAhZGVlcEVxdWFsKGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpLCBpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgaXNDdXJyZW50RmllbGREaXJ0eVxyXG4gICAgICAgICAgICAgICAgPyBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IHVuc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lKTtcclxuICAgICAgICAgICAgc3RhdGUuZGlydHlGaWVsZHMgPSBmb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcztcclxuICAgICAgICAgICAgaXNDaGFuZ2VkID1cclxuICAgICAgICAgICAgICAgIGlzQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNGaWVsZERpcnR5ICE9PSBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc1ByZXZpb3VzRmllbGRUb3VjaGVkID0gZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xyXG4gICAgICAgIGlmIChpc0N1cnJlbnRUb3VjaGVkICYmICFpc1ByZXZpb3VzRmllbGRUb3VjaGVkKSB7XHJcbiAgICAgICAgICAgIHNldChmb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkRmllbGRzLCBuYW1lLCBpc0N1cnJlbnRUb3VjaGVkKTtcclxuICAgICAgICAgICAgc3RhdGUudG91Y2hlZEZpZWxkcyA9IGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHM7XHJcbiAgICAgICAgICAgIGlzQ2hhbmdlZCA9XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5nZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCAhPT0gaXNDdXJyZW50VG91Y2hlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzQ2hhbmdlZCAmJiBzaG91bGRSZW5kZXIgJiYgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHN0YXRlKTtcclxuICAgICAgICByZXR1cm4gaXNDaGFuZ2VkID8gc3RhdGUgOiB7fTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVJbmxpbmVWYWxpZGF0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKG5hbWUsIHNraXBSZVJlbmRlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKVtuYW1lXTtcclxuICAgICAgICBhd2FpdCBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihza2lwUmVSZW5kZXIsIG5hbWUsIGVycm9yKTtcclxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZXJyb3IpO1xyXG4gICAgfSwgW2lzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXSk7XHJcbiAgICBjb25zdCBleGVjdXRlUmVzb2x2ZXJWYWxpZGF0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKG5hbWVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IHJlc29sdmVyUmVmLmN1cnJlbnQoZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZiksIGNvbnRleHRSZWYuY3VycmVudCwgZ2V0UmVzb2x2ZXJPcHRpb25zKG5hbWVzUmVmLmN1cnJlbnQubW91bnQsIGZpZWxkc1JlZi5jdXJyZW50LCBjcml0ZXJpYU1vZGUsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKTtcclxuICAgICAgICBpZiAobmFtZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICA/IHNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUsIGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5zZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3JzO1xyXG4gICAgfSwgW2NyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbl0pO1xyXG4gICAgY29uc3QgdmFsaWRhdGVGb3JtID0gYXN5bmMgKGZpZWxkc1JlZiwgc2hvdWxkQ2hlY2tWYWxpZCwgY29udGV4dCA9IHtcclxuICAgICAgICB2YWxpZDogdHJ1ZSxcclxuICAgIH0pID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzUmVmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9mID0gZmllbGQuX2Y7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gb21pdChmaWVsZCwgJ19mJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2YpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEVycm9yID0gYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRDaGVja1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEVycm9yW19mLm5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcltfZi5uYW1lXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBfZi5uYW1lLCBmaWVsZEVycm9yW19mLm5hbWVdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIF9mLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgJiYgKGF3YWl0IHZhbGlkYXRlRm9ybShjdXJyZW50LCBzaG91bGRDaGVja1ZhbGlkLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdHJpZ2dlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpO1xyXG4gICAgICAgIGxldCBpc1ZhbGlkO1xyXG4gICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hUmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVJlc29sdmVyVmFsaWRhdGlvbihpc1VuZGVmaW5lZChuYW1lKSA/IG5hbWUgOiBmaWVsZE5hbWVzKTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IG5hbWVcclxuICAgICAgICAgICAgICAgID8gZmllbGROYW1lcy5ldmVyeSgobmFtZSkgPT4gIWdldChzY2hlbWFSZXN1bHQsIG5hbWUpKVxyXG4gICAgICAgICAgICAgICAgOiBpc0VtcHR5T2JqZWN0KHNjaGVtYVJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IChhd2FpdCBQcm9taXNlLmFsbChmaWVsZE5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZmllbGROYW1lKSA9PiBnZXQoZmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkTmFtZSwge30pLl9mKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYXN5bmMgKGZpZWxkTmFtZSkgPT4gYXdhaXQgZXhlY3V0ZUlubGluZVZhbGlkYXRpb24oZmllbGROYW1lLCB0cnVlKSkpKS5ldmVyeShCb29sZWFuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlRm9ybShmaWVsZHNSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChpc1N0cmluZyhuYW1lKSA/IHsgbmFtZSB9IDoge30pKSwgeyBlcnJvcnM6IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycywgaXNWYWxpZGF0aW5nOiBmYWxzZSB9KSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgZm9jdXNGaWVsZEJ5KGZpZWxkc1JlZi5jdXJyZW50LCAoa2V5KSA9PiBnZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBrZXkpLCBuYW1lID8gZmllbGROYW1lcyA6IG5hbWVzUmVmLmN1cnJlbnQubW91bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCAmJiB1cGRhdGVJc1ZhbGlkKCk7XHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9LCBbZXhlY3V0ZVJlc29sdmVyVmFsaWRhdGlvbiwgZXhlY3V0ZUlubGluZVZhbGlkYXRpb25dKTtcclxuICAgIGNvbnN0IHVwZGF0ZUlzVmFsaWRBbmRJbnB1dFZhbHVlID0gKG5hbWUsIHJlZiwgc2hvdWxkU2tpcFZhbHVlQXMpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVVbmRlZmluZWQgPSBpc1VuZGVmaW5lZChmaWVsZC5fZi52YWx1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGlzVmFsdWVVbmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQoZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICA6IGdldChmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBmaWVsZC5fZi52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmICYmIHJlZi5kZWZhdWx0Q2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLnZhbHVlID0gZ2V0RmllbGRWYWx1ZShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTa2lwVmFsdWVBcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRWYWx1ZShuYW1lLCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVVbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkLl9mLnZhbHVlID0gZ2V0RmllbGRWYWx1ZShmaWVsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdXBkYXRlSXNWYWxpZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUlzVmFsaWQgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAodmFsdWVzID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gcmVzb2x2ZXJcclxuICAgICAgICAgICAgPyBpc0VtcHR5T2JqZWN0KChhd2FpdCByZXNvbHZlclJlZi5jdXJyZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZikpLCB2YWx1ZXMpLCBjb250ZXh0UmVmLmN1cnJlbnQsIGdldFJlc29sdmVyT3B0aW9ucyhuYW1lc1JlZi5jdXJyZW50Lm1vdW50LCBmaWVsZHNSZWYuY3VycmVudCwgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSkpLmVycm9ycylcclxuICAgICAgICAgICAgOiBhd2FpdCB2YWxpZGF0ZUZvcm0oZmllbGRzUmVmLmN1cnJlbnQsIHRydWUpO1xyXG4gICAgICAgIGlmIChpc1ZhbGlkICE9PSBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgPSBpc1ZhbGlkO1xyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbl0pO1xyXG4gICAgY29uc3Qgc2V0VmFsdWVzID0gUmVhY3QudXNlQ2FsbGJhY2soKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2ZpZWxkS2V5LCBmaWVsZFZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke25hbWV9LiR7ZmllbGRLZXl9YDtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgZmllbGROYW1lKTtcclxuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBuYW1lc1JlZi5jdXJyZW50LmFycmF5LmhhcyhuYW1lKTtcclxuICAgICAgICAoaXNGaWVsZEFycmF5IHx8ICFpc1ByaW1pdGl2ZShmaWVsZFZhbHVlKSB8fCAoZmllbGQgJiYgIWZpZWxkLl9mKSkgJiZcclxuICAgICAgICAgICAgIWlzRGF0ZU9iamVjdChmaWVsZFZhbHVlKVxyXG4gICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMsIHRydWUsICFmaWVsZCk7XHJcbiAgICB9KSwgW3RyaWdnZXJdKTtcclxuICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5ID0gbmFtZXNSZWYuY3VycmVudC5hcnJheS5oYXMobmFtZSk7XHJcbiAgICAgICAgaWYgKGlzRmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LmFycmF5Lm5leHQoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBpc1Jlc2V0OiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSB8fFxyXG4gICAgICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzKSAmJlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBzZXRGaWVsZEFycmF5RGlydHlGaWVsZHModmFsdWUsIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSwgZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzLCBuYW1lLCBbXSkpKTtcclxuICAgICAgICAgICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkczogZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eTogZ2V0SXNEaXJ0eShuYW1lLCB2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAhdmFsdWUubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICBzZXQoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSAmJlxyXG4gICAgICAgICAgICAgICAgc2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKChmaWVsZCAmJiAhZmllbGQuX2YpIHx8IGlzRmllbGRBcnJheSkgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxyXG4gICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCB2YWx1ZSwgaXNGaWVsZEFycmF5ID8ge30gOiBvcHRpb25zKVxyXG4gICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgdmFsdWUsIG9wdGlvbnMsIHRydWUsICFmaWVsZCk7XHJcbiAgICAgICAgaXNGaWVsZFdhdGNoZWQobmFtZSkgJiYgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHt9KTtcclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LndhdGNoLm5leHQoeyBuYW1lLCB2YWx1ZXM6IGdldFZhbHVlcygpIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZVZhbGlkYXRlID0gYXN5bmMgKHRhcmdldCwgZmllbGRTdGF0ZSwgaXNXYXRjaGVkLCBpc0JsdXJFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBlcnJvcjtcclxuICAgICAgICBsZXQgaXNWYWxpZDtcclxuICAgICAgICBsZXQgbmFtZSA9IHRhcmdldC5uYW1lO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IHJlc29sdmVyUmVmLmN1cnJlbnQoZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZiksIGNvbnRleHRSZWYuY3VycmVudCwgZ2V0UmVzb2x2ZXJPcHRpb25zKFtuYW1lXSwgZmllbGRzUmVmLmN1cnJlbnQsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpO1xyXG4gICAgICAgICAgICBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNDaGVja0JveElucHV0KHRhcmdldCkgJiYgIWVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlTmFtZSA9IGdldE5vZGVQYXJlbnROYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEVycm9yID0gZ2V0KGVycm9ycywgcGFyZW50Tm9kZU5hbWUsIHt9KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFcnJvci50eXBlICYmIGN1cnJlbnRFcnJvci5tZXNzYWdlICYmIChlcnJvciA9IGN1cnJlbnRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVycm9yIHx8IGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIHBhcmVudE5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJlbnROb2RlTmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IgPSAoYXdhaXQgdmFsaWRhdGVGaWVsZChmaWVsZCwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKVtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgIWlzQmx1ckV2ZW50ICYmXHJcbiAgICAgICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQud2F0Y2gubmV4dCh7XHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGFyZ2V0LnR5cGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGdldFZhbHVlcygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihmYWxzZSwgbmFtZSwgZXJyb3IsIGZpZWxkU3RhdGUsIGlzVmFsaWQsIGlzV2F0Y2hlZCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKHsgdHlwZSwgdGFyZ2V0LCB0YXJnZXQ6IHsgdmFsdWUsIG5hbWUsIHR5cGU6IGlucHV0VHlwZSB9IH0pID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dFZhbHVlID0gaW5wdXRUeXBlID8gZ2V0RmllbGRWYWx1ZShmaWVsZCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSA/IHZhbHVlIDogaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgaXNCbHVyRXZlbnQgPSB0eXBlID09PSBFVkVOVFMuQkxVUjtcclxuICAgICAgICAgICAgY29uc3QgeyBpc09uQmx1cjogaXNSZVZhbGlkYXRlT25CbHVyLCBpc09uQ2hhbmdlOiBpc1JlVmFsaWRhdGVPbkNoYW5nZSwgfSA9IGdldFZhbGlkYXRpb25Nb2RlcyhyZVZhbGlkYXRlTW9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mLCBmaWVsZC5fZi5tb3VudCkgJiZcclxuICAgICAgICAgICAgICAgICFyZXNvbHZlciAmJlxyXG4gICAgICAgICAgICAgICAgIWdldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIG5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oT2JqZWN0LmFzc2lnbih7IGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQ6ICEhZ2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBpc1N1Ym1pdHRlZDogZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNTdWJtaXR0ZWQsIGlzUmVWYWxpZGF0ZU9uQmx1cixcclxuICAgICAgICAgICAgICAgICAgICBpc1JlVmFsaWRhdGVPbkNoYW5nZSB9LCB2YWxpZGF0aW9uTW9kZSkpO1xyXG4gICAgICAgICAgICBjb25zdCBpc1dhdGNoZWQgPSAhaXNCbHVyRXZlbnQgJiYgaXNGaWVsZFdhdGNoZWQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkLl9mLnZhbHVlID0gaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eVN0YXRlKG5hbWUsIGZpZWxkLl9mLnZhbHVlLCBpc0JsdXJFdmVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCBpc1dhdGNoZWQ7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC53YXRjaC5uZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBnZXRWYWx1ZXMoKSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2hvdWxkUmVuZGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KGlzV2F0Y2hlZCA/IHsgbmFtZSB9IDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZFN0YXRlKSwgeyBuYW1lIH0pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZVZhbGlkYXRlKHRhcmdldCwgZmllbGRTdGF0ZSwgaXNXYXRjaGVkLCBpc0JsdXJFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0VmFsdWVzID0gKGZpZWxkTmFtZXMpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCksIGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYpKTtcclxuICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoZmllbGROYW1lcylcclxuICAgICAgICAgICAgPyB2YWx1ZXNcclxuICAgICAgICAgICAgOiBpc1N0cmluZyhmaWVsZE5hbWVzKVxyXG4gICAgICAgICAgICAgICAgPyBnZXQodmFsdWVzLCBmaWVsZE5hbWVzKVxyXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNsZWFyRXJyb3JzID0gKG5hbWUpID0+IHtcclxuICAgICAgICBuYW1lXHJcbiAgICAgICAgICAgID8gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBpbnB1dE5hbWUpKVxyXG4gICAgICAgICAgICA6IChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMgPSB7fSk7XHJcbiAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgZXJyb3JzOiBmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0RXJyb3IgPSAobmFtZSwgZXJyb3IsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBjb25zdCByZWYgPSAoKGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSkgfHwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcclxuICAgICAgICBzZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yKSwgeyByZWYgfSkpO1xyXG4gICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIGVycm9yczogZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB3YXRjaEludGVybmFsID0gUmVhY3QudXNlQ2FsbGJhY2soKGZpZWxkTmFtZXMsIGRlZmF1bHRWYWx1ZSwgaXNHbG9iYWwsIGZvcm1WYWx1ZXMpID0+IHtcclxuICAgICAgICBjb25zdCBpc0FycmF5TmFtZXMgPSBBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZm9ybVZhbHVlcyB8fCBpc01vdW50ZWRSZWYuY3VycmVudFxyXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50KSwgKGZvcm1WYWx1ZXMgfHwgZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZikpKSA6IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgOiBpc0FycmF5TmFtZXNcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXHJcbiAgICAgICAgICAgICAgICA6IHsgW2ZpZWxkTmFtZXNdOiBkZWZhdWx0VmFsdWUgfTtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZmllbGROYW1lcykpIHtcclxuICAgICAgICAgICAgaXNHbG9iYWwgJiYgKG5hbWVzUmVmLmN1cnJlbnQud2F0Y2hBbGwgPSB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBjb252ZXJ0VG9BcnJheVBheWxvYWQoZmllbGROYW1lcykpIHtcclxuICAgICAgICAgICAgaXNHbG9iYWwgJiYgbmFtZXNSZWYuY3VycmVudC53YXRjaC5hZGQoZmllbGROYW1lKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2V0KGZpZWxkVmFsdWVzLCBmaWVsZE5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlOYW1lcyA/IHJlc3VsdCA6IHJlc3VsdFswXTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHdhdGNoID0gKGZpZWxkTmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKGZpZWxkTmFtZSlcclxuICAgICAgICA/IHN1YmplY3RzUmVmLmN1cnJlbnQud2F0Y2guc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgbmV4dDogKGluZm8pID0+IGZpZWxkTmFtZSh3YXRjaEludGVybmFsKHVuZGVmaW5lZCwgZGVmYXVsdFZhbHVlKSwgaW5mbyksXHJcbiAgICAgICAgfSlcclxuICAgICAgICA6IHdhdGNoSW50ZXJuYWwoZmllbGROYW1lLCBkZWZhdWx0VmFsdWUsIHRydWUpO1xyXG4gICAgY29uc3QgdW5yZWdpc3RlciA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGlucHV0TmFtZSBvZiBuYW1lXHJcbiAgICAgICAgICAgID8gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpXHJcbiAgICAgICAgICAgIDogbmFtZXNSZWYuY3VycmVudC5tb3VudCkge1xyXG4gICAgICAgICAgICBuYW1lc1JlZi5jdXJyZW50Lm1vdW50LmRlbGV0ZShpbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICBuYW1lc1JlZi5jdXJyZW50LmFycmF5LmRlbGV0ZShpbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBpbnB1dE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRXJyb3IgJiYgdW5zZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzLCBpbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgIW9wdGlvbnMua2VlcFZhbHVlICYmIHVuc2V0KGZpZWxkc1JlZi5jdXJyZW50LCBpbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoZm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMsIGlucHV0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHVuc2V0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHMsIGlucHV0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAhc2hvdWxkVW5yZWdpc3RlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBEZWZhdWx0VmFsdWUgJiZcclxuICAgICAgICAgICAgICAgICAgICB1bnNldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIGlucHV0TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC53YXRjaC5uZXh0KHtcclxuICAgICAgICAgICAgdmFsdWVzOiBnZXRWYWx1ZXMoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtU3RhdGVSZWYuY3VycmVudCksICghb3B0aW9ucy5rZWVwRGlydHkgPyB7fSA6IHsgaXNEaXJ0eTogZ2V0SXNEaXJ0eSgpIH0pKSk7XHJcbiAgICAgICAgIW9wdGlvbnMua2VlcElzVmFsaWQgJiYgdXBkYXRlSXNWYWxpZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlZ2lzdGVyRmllbGRSZWYgPSAobmFtZSwgcmVmLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmVnaXN0ZXIobmFtZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24ocmVmKTtcclxuICAgICAgICBpZiAocmVmID09PSBmaWVsZC5fZi5yZWYgfHxcclxuICAgICAgICAgICAgKGlzUmFkaW9PckNoZWNrYm94ICYmXHJcbiAgICAgICAgICAgICAgICBjb21wYWN0KGZpZWxkLl9mLnJlZnMgfHwgW10pLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uID09PSByZWYpKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkID0ge1xyXG4gICAgICAgICAgICBfZjogaXNSYWRpb09yQ2hlY2tib3hcclxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZC5fZiksIHsgcmVmczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb21wYWN0KGZpZWxkLl9mLnJlZnMgfHwgW10pLmZpbHRlcigocmVmKSA9PiBpc0hUTUxFbGVtZW50KHJlZikgJiYgZG9jdW1lbnQuY29udGFpbnMocmVmKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgICAgICBdLCByZWY6IHsgdHlwZTogcmVmLnR5cGUsIG5hbWUgfSB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQuX2YpLCB7IHJlZiB9KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgZmllbGQpO1xyXG4gICAgICAgIHVwZGF0ZUlzVmFsaWRBbmRJbnB1dFZhbHVlKG5hbWUsIHJlZik7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjaygobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIHNldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSwge1xyXG4gICAgICAgICAgICBfZjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChmaWVsZCAmJiBmaWVsZC5fZiA/IGZpZWxkLl9mIDogeyByZWY6IHsgbmFtZSB9IH0pKSwgeyBuYW1lLCBtb3VudDogdHJ1ZSB9KSwgb3B0aW9ucyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbmFtZXNSZWYuY3VycmVudC5tb3VudC5hZGQobmFtZSk7XHJcbiAgICAgICAgIWZpZWxkICYmIHVwZGF0ZUlzVmFsaWRBbmRJbnB1dFZhbHVlKG5hbWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGlzV2luZG93VW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8geyBuYW1lOiBuYW1lIH1cclxuICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcclxuICAgICAgICAgICAgICAgIG9uQmx1cjogaGFuZGxlQ2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVmOiAocmVmKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlckZpZWxkUmVmKG5hbWUsIHJlZiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHNSZWYuY3VycmVudCwgbmFtZSwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRVbm1vdW50ID0gc2hvdWxkVW5yZWdpc3RlciB8fCBvcHRpb25zLnNob3VsZFVucmVnaXN0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5fZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGluaXRpYWwgc3RhdGUgb2YgZmllbGQgZWxlbWVudCBpcyBkaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGlzIG5vdCBzZXQgb24gZmlyc3QgXCJyZWdpc3RlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1zeW5jIHRoZSB2YWx1ZSBpbiB3aGVuIGl0IHN3aXRjaGVkIHRvIGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmaWVsZC5fZi52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi52YWx1ZSA9IGZpZWxkLl9mLnJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRVbm1vdW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGlzTmFtZUluRmllbGRBcnJheShuYW1lc1JlZi5jdXJyZW50LmFycmF5LCBuYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluRmllbGRBcnJheUFjdGlvblJlZi5jdXJyZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNSZWYuY3VycmVudC51bk1vdW50LmFkZChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gUmVhY3QudXNlQ2FsbGJhY2soKG9uVmFsaWQsIG9uSW52YWxpZCkgPT4gYXN5bmMgKGUpID0+IHtcclxuICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5wZXJzaXN0ICYmIGUucGVyc2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaGFzTm9Qcm9taXNlRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYpO1xyXG4gICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzLCB2YWx1ZXMgfSA9IGF3YWl0IHJlc29sdmVyUmVmLmN1cnJlbnQoZmllbGRWYWx1ZXMsIGNvbnRleHRSZWYuY3VycmVudCwgZ2V0UmVzb2x2ZXJPcHRpb25zKG5hbWVzUmVmLmN1cnJlbnQubW91bnQsIGZpZWxkc1JlZi5jdXJyZW50LCBjcml0ZXJpYU1vZGUsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKTtcclxuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycyA9IGVycm9ycztcclxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVGb3JtKGZpZWxkc1JlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpICYmXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMpLmV2ZXJ5KChuYW1lKSA9PiBnZXQoZmllbGRWYWx1ZXMsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbkludmFsaWQgJiYgKGF3YWl0IG9uSW52YWxpZChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIGUpKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRXJyb3IgJiZcclxuICAgICAgICAgICAgICAgICAgICBmb2N1c0ZpZWxkQnkoZmllbGRzUmVmLmN1cnJlbnQsIChrZXkpID0+IGdldChmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsIGtleSksIG5hbWVzUmVmLmN1cnJlbnQubW91bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaGFzTm9Qcm9taXNlRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgZm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNTdWJtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZVJlZi5jdXJyZW50LmVycm9ycykgJiYgaGFzTm9Qcm9taXNlRXJyb3IsXHJcbiAgICAgICAgICAgICAgICBzdWJtaXRDb3VudDogZm9ybVN0YXRlUmVmLmN1cnJlbnQuc3VibWl0Q291bnQgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBmb3JtU3RhdGVSZWYuY3VycmVudC5lcnJvcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtcclxuICAgICAgICBzaG91bGRGb2N1c0Vycm9yLFxyXG4gICAgICAgIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLFxyXG4gICAgICAgIGNyaXRlcmlhTW9kZSxcclxuICAgICAgICBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLFxyXG4gICAgXSk7XHJcbiAgICBjb25zdCByZWdpc3RlckFic2VudEZpZWxkcyA9IChkZWZhdWx0VmFsdWVzLCBuYW1lID0gJycpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVmYXVsdFZhbHVlc1trZXldO1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lICsgKG5hbWUgPyAnLicgOiAnJykgKyBrZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5fZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQWJzZW50RmllbGRzKHZhbHVlLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIoZmllbGROYW1lLCB7IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0ID0gKHZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IHZhbHVlcyB8fCBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGlzV2ViICYmICFrZWVwU3RhdGVPcHRpb25zLmtlZXBWYWx1ZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzUmVmLmN1cnJlbnQubW91bnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0UmVmID0gQXJyYXkuaXNBcnJheShmaWVsZC5fZi5yZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnNbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZC5fZi5yZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChpbnB1dFJlZikgJiYgaW5wdXRSZWYuY2xvc2VzdCgnZm9ybScpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcykge1xyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkVmFsdWVzKTtcclxuICAgICAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZWRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xyXG4gICAgICAgICAgICBmaWVsZHNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LmNvbnRyb2wubmV4dCh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudFxyXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZFZhbHVlcyksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZi5jdXJyZW50LndhdGNoLm5leHQoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzOiBPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkVmFsdWVzKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN1YmplY3RzUmVmLmN1cnJlbnQuYXJyYXkubmV4dCh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZWRWYWx1ZXMpLFxyXG4gICAgICAgICAgICAgICAgaXNSZXNldDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5hbWVzUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgICAgIG1vdW50OiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgc3VibWl0Q291bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFN1Ym1pdENvdW50XHJcbiAgICAgICAgICAgICAgICA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LnN1Ym1pdENvdW50XHJcbiAgICAgICAgICAgICAgICA6IDAsXHJcbiAgICAgICAgICAgIGlzRGlydHk6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XHJcbiAgICAgICAgICAgICAgICA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHlcclxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgID8gZGVlcEVxdWFsKHZhbHVlcywgZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxyXG4gICAgICAgICAgICAgICAgPyBmb3JtU3RhdGVSZWYuY3VycmVudC5pc1N1Ym1pdHRlZFxyXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgZGlydHlGaWVsZHM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XHJcbiAgICAgICAgICAgICAgICA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LmRpcnR5RmllbGRzXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBUb3VjaGVkXHJcbiAgICAgICAgICAgICAgICA/IGZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWRGaWVsZHNcclxuICAgICAgICAgICAgICAgIDoge30sXHJcbiAgICAgICAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gZm9ybVN0YXRlUmVmLmN1cnJlbnQuZXJyb3JzIDoge30sXHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0Rm9jdXMgPSAobmFtZSkgPT4gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKS5fZi5yZWYuZm9jdXMoKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZm9ybVN0YXRlU3Vic2NyaXB0aW9uID0gc3ViamVjdHNSZWYuY3VycmVudC5zdGF0ZS5zdWJzY3JpYmUoe1xyXG4gICAgICAgICAgICBuZXh0KGZvcm1TdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbmRlckZvcm1TdGF0ZShmb3JtU3RhdGUsIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudCwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtU3RhdGVSZWYuY3VycmVudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybVN0YXRlUmVmLmN1cnJlbnQpLCBmb3JtU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdXNlRmllbGRBcnJheVN1YnNjcmlwdGlvbiA9IHN1YmplY3RzUmVmLmN1cnJlbnQuYXJyYXkuc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgbmV4dChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnZhbHVlcyAmJiBzdGF0ZS5uYW1lICYmIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZ2V0RmllbGRzVmFsdWVzKGZpZWxkc1JlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlcywgc3RhdGUubmFtZSwgc3RhdGUudmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJc1ZhbGlkKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZm9ybVN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIHVzZUZpZWxkQXJyYXlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB1bnJlZ2lzdGVyRmllbGROYW1lcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGlzTGl2ZUluRG9tID0gKHJlZikgPT4gIWlzSFRNTEVsZW1lbnQocmVmKSB8fCAhZG9jdW1lbnQuY29udGFpbnMocmVmKTtcclxuICAgICAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdXBkYXRlSXNWYWxpZCgpO1xyXG4gICAgICAgICAgICAhc2hvdWxkVW5yZWdpc3RlciAmJiByZWdpc3RlckFic2VudEZpZWxkcyhkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXNSZWYuY3VycmVudC51bk1vdW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgZmllbGQgJiZcclxuICAgICAgICAgICAgICAgIChmaWVsZC5fZi5yZWZzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzLmV2ZXJ5KGlzTGl2ZUluRG9tKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNMaXZlSW5Eb20oZmllbGQuX2YucmVmKSkgJiZcclxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJGaWVsZE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVucmVnaXN0ZXJGaWVsZE5hbWVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyKHVucmVnaXN0ZXJGaWVsZE5hbWVzKTtcclxuICAgICAgICBuYW1lc1JlZi5jdXJyZW50LnVuTW91bnQgPSBuZXcgU2V0KCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29udHJvbDogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xyXG4gICAgICAgICAgICByZWdpc3RlcixcclxuICAgICAgICAgICAgaW5GaWVsZEFycmF5QWN0aW9uUmVmLFxyXG4gICAgICAgICAgICBnZXRJc0RpcnR5LFxyXG4gICAgICAgICAgICBzdWJqZWN0c1JlZixcclxuICAgICAgICAgICAgd2F0Y2hJbnRlcm5hbCxcclxuICAgICAgICAgICAgZmllbGRzUmVmLFxyXG4gICAgICAgICAgICB1cGRhdGVJc1ZhbGlkLFxyXG4gICAgICAgICAgICBuYW1lc1JlZixcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZixcclxuICAgICAgICAgICAgZm9ybVN0YXRlUmVmLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzUmVmLFxyXG4gICAgICAgICAgICBmaWVsZEFycmF5RGVmYXVsdFZhbHVlc1JlZixcclxuICAgICAgICAgICAgc2V0VmFsdWVzLFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxyXG4gICAgICAgICAgICBzaG91bGRVbm1vdW50OiBzaG91bGRVbnJlZ2lzdGVyLFxyXG4gICAgICAgIH0pLCBbXSksXHJcbiAgICAgICAgZm9ybVN0YXRlOiBnZXRQcm94eUZvcm1TdGF0ZShpc1Byb3h5RW5hYmxlZCwgZm9ybVN0YXRlLCByZWFkRm9ybVN0YXRlUmVmKSxcclxuICAgICAgICB0cmlnZ2VyLFxyXG4gICAgICAgIHJlZ2lzdGVyLFxyXG4gICAgICAgIGhhbmRsZVN1Ym1pdCxcclxuICAgICAgICB3YXRjaDogUmVhY3QudXNlQ2FsbGJhY2sod2F0Y2gsIFtdKSxcclxuICAgICAgICBzZXRWYWx1ZTogUmVhY3QudXNlQ2FsbGJhY2soc2V0VmFsdWUsIFtzZXRWYWx1ZXNdKSxcclxuICAgICAgICBnZXRWYWx1ZXM6IFJlYWN0LnVzZUNhbGxiYWNrKGdldFZhbHVlcywgW10pLFxyXG4gICAgICAgIHJlc2V0OiBSZWFjdC51c2VDYWxsYmFjayhyZXNldCwgW10pLFxyXG4gICAgICAgIGNsZWFyRXJyb3JzOiBSZWFjdC51c2VDYWxsYmFjayhjbGVhckVycm9ycywgW10pLFxyXG4gICAgICAgIHVucmVnaXN0ZXI6IFJlYWN0LnVzZUNhbGxiYWNrKHVucmVnaXN0ZXIsIFtdKSxcclxuICAgICAgICBzZXRFcnJvcjogUmVhY3QudXNlQ2FsbGJhY2soc2V0RXJyb3IsIFtdKSxcclxuICAgICAgICBzZXRGb2N1czogUmVhY3QudXNlQ2FsbGJhY2soc2V0Rm9jdXMsIFtdKSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gdXNlV2F0Y2gocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlIH0gPSBwcm9wcyB8fCB7fTtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgbmFtZVJlZiA9IFJlYWN0LnVzZVJlZihuYW1lKTtcclxuICAgIG5hbWVSZWYuY3VycmVudCA9IG5hbWU7XHJcbiAgICBjb25zdCB7IHdhdGNoSW50ZXJuYWwsIHN1YmplY3RzUmVmIH0gPSBjb250cm9sIHx8IG1ldGhvZHMuY29udHJvbDtcclxuICAgIGNvbnN0IFt2YWx1ZSwgdXBkYXRlVmFsdWVdID0gUmVhY3QudXNlU3RhdGUoaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgID8gd2F0Y2hJbnRlcm5hbChuYW1lKVxyXG4gICAgICAgIDogZGVmYXVsdFZhbHVlKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgd2F0Y2hJbnRlcm5hbChuYW1lKTtcclxuICAgICAgICBjb25zdCB3YXRjaFN1YnNjcmlwdGlvbiA9IHN1YmplY3RzUmVmLmN1cnJlbnQud2F0Y2guc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgbmV4dDogKHsgbmFtZTogaW5wdXROYW1lLCB2YWx1ZXMgfSkgPT4gKCFuYW1lUmVmLmN1cnJlbnQgfHxcclxuICAgICAgICAgICAgICAgICFpbnB1dE5hbWUgfHxcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lUmVmLmN1cnJlbnQpLnNvbWUoKGZpZWxkTmFtZSkgPT4gaW5wdXROYW1lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkTmFtZS5zdGFydHNXaXRoKGlucHV0TmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lLnN0YXJ0c1dpdGgoZmllbGROYW1lKSkpKSAmJlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUod2F0Y2hJbnRlcm5hbChuYW1lUmVmLmN1cnJlbnQsIGRlZmF1bHRWYWx1ZSwgZmFsc2UsIHZhbHVlcykpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB3YXRjaFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIEZvcm1Qcm92aWRlciwgYXBwZW5kRXJyb3JzLCBnZXQsIHNldCwgdXNlQ29udHJvbGxlciwgdXNlRmllbGRBcnJheSwgdXNlRm9ybSwgdXNlRm9ybUNvbnRleHQsIHVzZUZvcm1TdGF0ZSwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-hook-form/dist/index.esm.js\n");

/***/ })

});